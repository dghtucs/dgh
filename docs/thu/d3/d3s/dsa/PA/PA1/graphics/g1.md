## 算法思路和实现要点

把 x 轴上的 n 个横坐标升序为 `Px[0..n-1]`，y 轴上的 n 个纵坐标升序为 `Py[0..n-1]`，按相同下标配对 `(Px[i],0)-(0,Py[i])`，可证明得到的 n 条线段两两不相交。设查询点为 `P(x,y)`，考虑有向线段 `A=(0,Py[i]) → B=(Px[i],0)`，用叉积 `ToLeft = (B-A)×(P-A)` 判断 P 在该线段“左侧/线上”还是“右侧”。随着 i 增大，线段的支撑直线单调“外旋”，`ToLeft` 的符号对 i 单调，于是答案就是满足 `ToLeft≥0` 的最大 i 的下标 +1。实现上：对 `Px`、`Py` 各自归并排序；对每次查询用二分在 `[0,n-1]` 上找分界点，边界特判（全右侧得 0，全左侧得 n）。

## 渐进时间复杂度的分析，包含过程

预处理对 `Px`、`Py` 各做一次排序，归并排序为 `O(n log n)`。每次查询仅做常数次 `ToLeft`（O(1)）与一次二分查找（O(log n)）。因此总时间为
`T(n,m)=O(n log n) + m·O(log n) = O(n log n + m log n)`。

## 渐进空间复杂度的分析，包含过程

除输入外，主要占用：两段长度为 n 的数组 `Px、Py`（题目不计入输入存储可忽略），归并排序的临时数组 `L、R` 总体 `O(n)`，以及递归栈 `O(log n)`。查询阶段只用常数额外空间。综合得额外空间复杂度 `S(n)=O(n)`。

## 遇到的困难和解决方法

* 叉积溢出风险：坐标 < 2³¹，乘积可达约 2⁶²，统一使用 `long long` 解决。
* 二分边界与等号处理：将“在线上”的情况计入左侧（`>=0`），并对最左、最右两条线段做特判，避免越界与 off-by-one。
* 线段不相交的配对依据：先分别排序再按位配对即可保证单调与不相交。

## 估计完成本题所用时间

1.2 小时


