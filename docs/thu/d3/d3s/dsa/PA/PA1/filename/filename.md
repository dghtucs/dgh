# 实验报告

## 基本思路
本题需要计算从字符串A到字符串B的操作次数，这里可以很自然地和课上讲过的公共子序列联系起来，字符串A和B的最长公共子序列可以看作是，两者之间转换必经的节点（如果要达到最少操作的效果），因此，不难想到，最后的最少操作次数，就是字符串A和B各自与最长公共子序列之间的距离。
$$
res = len(A)-len(lcs) + len(B)-len(lcs)
$$
因此问题就转化为求两个字符串的最长公共子序列的长度

## 优化过程

### 暴力解法

最开始我直接开了$m*n$的二维数组进行动态规划，不出意外地爆内存了
数据规模在$501000^2 \approx 2.5\times10^{11}$大于$1\times10^9$,所以同时在空间和时间上不符合要求。

### 减小内存使用

注意到动态规划在更新状态时可以循环使用数组，因此申请数组时，只申请两行，减小内存负担

```
int dp[2][n + 1];
    memset(dp, 0, sizeof(dp));
```

### 利用k进行剪枝

我发现在优化之后，还是会造成TLE，这是因为在更新状态时，可以根据k来拒绝某些越界状态的访问，只需要更新主对角线，以及距离主对角线小于k的节点，这样可以降低复杂度。


## 时空复杂度分析
### 时间复杂度
动态规划部分：
外层循环遍历 m（字符串 str1 的长度），内层循环遍历 n（字符串 str2 的长度），在最坏情况下，两个循环的复杂度为 O(m * n)。
由于使用了剪枝（基于 k），实际访问的元素可能会减少。因此，平均情况下的时间复杂度会低于 O(m * n)，但在最坏情况下仍然为 O(m * n)。

总体复杂度：
最终，调用 longestCommonSubsequence 函数的时间复杂度是 O(m * n)。
### 空间复杂度
动态规划数组：
使用了一个大小为 2 x (n + 1) 的二维数组 dp，因此空间复杂度为 O(n)。
字符串存储：
分配了两个字符串的空间，大小为 O(m + n)，但这些内存是动态分配的。
整体的空间复杂度为 O(n)，因为 dp 数组的大小主导了空间使用。
### 总结
时间复杂度：O(m * n)（最坏情况下），整体的空间复杂度为 O(n)







