## 算法思路和实现要点

只允许“插入/删除”的编辑距离：把把 A 变为 B 的最小代价用带状 DP 求解。设 `dp[i][j]` 为把 `A[0..i-1]` 变成 `B[0..j-1]` 的最小代价，转移为：

* 删：`dp[i-1][j]+1`
* 插：`dp[i][j-1]+1`
* 匹配/“替换”(视作删+插)：`dp[i-1][j-1] + (A[i-1]==B[j-1]?0:2)`
  因答案若 ≤K，则最优路径始终满足 `|i-j|≤K`，据此做带状优化，只在带内计算；并滚动数组仅保留上一行与当前行，边界 `j==0` 单独处理。先判 `|n-m|>K` 直接输出 -1。

## 渐进时间复杂度的分析，包含过程

设 `n=|A|, m=|B|, N=min(n,m)`。带宽至多 `2K+1`，对每个 `i=1..N` 仅计算 `j∈[i-K, i+K]` 的至多 `2K+1` 个状态，每个状态 O(1) 更新，故总更新次数约 `(2K+1)·N`。忽略常数后，时间复杂度为 **O(K·min(n,m))**；当 `|n-m|>K` 时提前返回，耗时 O(1)。

## 渐进空间复杂度的分析，包含过程

带状 DP 仅需保存上一行与当前行在带内的值，各自长度 O(K)。因此额外空间为 **O(K)**。未把输入字符串本身计入空间复杂度。

## 遇到的困难和解决方法

1. 误用 LCS+窗口剪枝导致错解 → 改为直接对编辑距离做带状 DP。
2. 评测环境缺失 `<bits/stdc++.h>`/C++ 头导致编译失败 → 改为只包含必需标准头；或给出纯 C 版本。
3. 用 gcc 编译 C++ 代码报找不到 `<vector>` → 明确用 g++ 或提供纯 C 实现。
4. 带状边界易越界/漏值 → 统一用 `jL/jR`、`pL/pR` 管理窗口，`j==0` 与对角不存在时小心分支。

## 估计完成本题所用时间

3 小时

## 关于本题的更多感想

这题的关键在于认清操作模型（无替换）与善用 K 做带状优化。和传统 Levenshtein 相比，既要注意“替换=删+插”的代价，又要在实现上把窗口边界、滚动数组索引处理干净。
