

### 实验报告





#### 哈希实现思路


1.坏的

该哈希函数使用字符串的所有字符，但以不均匀的方式映射到哈希表中。具体做法是将每个字符的ASCII值乘以一个固定的素数（131），并累积这些乘积的和，然后取模表大小。


2.好的

均匀映射到哈希表中。将每个字符乘以固定素数（31），并累积这些乘积的和，然后取模表大小。使用31能够有效地将不同字符串的哈希值均匀地分布到表中，减少冲突，和不均匀哈希的区别是坏的哈希策略使用131作为乘数，哈希值分布不均，增加冲突。

3.双向平方

采用平方探测法解决冲突，每次冲突后尝试将冲突位置加上一个平方数（1, -1, 4, -4, 9, -9...）。这样可以更均匀地分散冲突位置，减少聚集效应。

4.公共溢出区策略

将哈希表的一部分作为公共溢出区，当发生冲突时，数据存储在溢出区中。初始插入和查询操作先在主区进行，当主区冲突时转到溢出区


#### 测试

```
./main <hash_strategy> <collision_strategy> <imput_file>
```
<hash_strategy> = 1 : bad_hashing
<hash_strategy> = 2 : good_hashing

<collision_strategy> = 0 : linear_probe
<collision_strategy> = 1 : quadratic_probe
<collision_strategy> = 2 : common_overflow

两两组合，一共可以生成六种策略。

#### 测试数据的构造方法
均匀分布

特征：包含大量均匀分布的插入和查询操作。
构造方法：从poj.txt中随机选择1000个条目进行插入操作，再随机选择1000个条目进行查询操作。


集中分布

特征：包含集中分布的插入和查询操作。
构造方法：从poj.txt中随机选择1000个条目进行插入操作，再从这些条目中随机选择100个条目重复查询1000次。


插入操作

特征：包含大量的插入操作和少量查询操作。
构造方法：从poj.txt中随机选择3000个条目进行插入操作，再随机选择300个条目进行查询操作。




#### 分析结果

1.

好的哈希函数性能更好，能够更均匀地将字符串映射到哈希表中，减少了冲突的发生次数

2.

双向平方试探的性能优于线性试探。双向平方试探通过在发生冲突时从哈希位置向两个方向探测，能够更均匀地分布数据

3.

封闭散列通常在负载较低时表现更好，因避免了管理公共溢出区的额外开销。而在负载较高时，开放散列（公共溢出区）表现更好，因为它能够有效减少聚集效应。

4.

实际数据中的字符分布不均匀会导致哈希值的聚集效应。某些哈希槽可能被滥用，有些很少使用

5.
先在每次操作之后计算当前负载因子，创建一个新哈希表相应扩容或缩容，然后所有元素插入新哈希表，释放旧表












