

# 01.cpp

## 错误类型
Runtime Error
会导致运行时崩溃


## 错误原因
在代码的 play 函数中，当 rank 值为 0 时，如果 a 为空，a.at(rank) 会导致越界访问并产生 std::out_of_range 错误。此外，如果 rank 值在 a 的末尾边界处时，play 函数可能会对超出字符串范围的位置进行访问。对于输入为 0 A 和 1 B，如果 a 已经被删除为空串，插入字符后再次调用 play 会导致此问题


## 构造思路
输入的 rank 值和字符串 a 的长度导致越界访问，尤其是在 rank 值接近或超出字符串的边界时会触发此问题。这里的输入 0 A 和 1 B 将触发越界，因为在 a 的初始状态为空，直接对索引 rank=0 进行访问将导致错误

# 02.cpp

## 错误类型
Runtime Error


## 错误原因
当输入为 2 行，且字符串 a 初始为空时，play 函数会因 a.at(rank) 越界访问而引发 std::out_of_range 异常。这是因为当 a 为空时，调用 a.at(rank) 会导致访问空字符串的第一个位置，这在 C++ 中是非法操作


## 构造思路
输入 2 和 0 A 会触发越界访问，因为 a 在 getline(cin, a); 读取后为空。随后的 rank=0 会试图访问 a.at(0)，从而导致运行时错误


# 03.cpp

## 错误类型
Wrong Answer


## 错误原因
play 函数的递归处理逻辑在链式消除时无法正确处理插入后的连锁消除效果。当输入为 ABBBA 且在索引 2 插入 B 后变为 ABBBBA 时，play 函数将尝试删除连续的 B 字符，但递归逻辑无法持续正确地检查字符串中新的相邻字符组合，因此未能按预期删除所有可以消除的字符，导致结果错误


## 构造思路
输入初始字符串为 ABBBA，接下来执行插入操作 2 B，会形成连续的 BBBB 字符串，符合 play 函数的消除条件（连续三个或更多字符）。测例构造利用了这种特殊位置插入来确保链式消除条件。然而，play 函数递归无法正确跟踪这种动态变化，导致错误答案输出

# 04.cpp

## 错误类型
Runtime Error


## 错误原因
在 play 函数的第一个 while 循环中，left 被设置为 rank，然后检查 a.at(left) 是否与 color 相同。当 left 为 0 时，执行 --left 会将 left 变为 -1。之后的 a.at(left) 访问会越界，导致 std::out_of_range 错误。此问题出现在代码未正确处理边界情况下的索引越界


## 构造思路
初始字符串为 AAAB，输入 0 意味着在 a 的开头插入字符。此操作会导致 play 函数在边界位置（索引为 0）进行访问，并引发负索引访问，进而导致越界错误

# 05.cpp

## 错误类型
Wrong Answer



## 错误原因
play 函数会递归地检查并消除相邻的相同字符，但是它没有完全处理多次递归链式消除的情况。在输入 AABBBAA 时，如果在位置 4 插入字符 B，字符串变为 AABBBBBAA。play 函数将消除 BBBBB，但此后不会继续检查并处理剩下的相邻字符，导致未能完全消除符合条件的字符组合。这样会产生错误的最终输出


## 构造思路
输入初始字符串为 AABBBAA，插入操作在索引 4 插入 B，产生一个长串 BBBBB 可消除字符。构造此测例的目的是检查程序是否能够正确执行链式消除，触发代码无法递归检查剩余相邻字符的逻辑漏洞

# 06.cpp

## 错误类型
Runtime Error


## 错误原因
play 函数的消除逻辑在处理边界时存在问题。当在 rank = 0 位置插入 A 时，代码会调用 get 函数来访问块的内容，并对消除条件进行检查。但是，在处理 Rank l 和 Rank r 时，由于 l 和 r 可能超出有效块的范围（特别是边界位置 l.second < 0 或 r.second >= plen[r.first]），导致 get 函数对无效块进行访问，从而引发越界访问或段错误（segmentation fault）


## 构造思路
输入 AA 和插入操作 0 A，触发边界位置的插入和随后的消除逻辑。由于 rank = 0 位于字符串的开头，当在边界处插入字符 A 后，代码会进入消除逻辑，此时访问 Rank l 会出现负索引访问的风险，而 Rank r 也可能超出块的有效范围，导致越界访问错误

# 07.cpp

## 错误类型
Runtime Error


## 错误原因
在处理输入 2 和 0 A 时，play 函数会尝试在索引 0 处插入字符 A。由于字符串 a 初始为空，a2p() 之后 plen[0] 也是 0，导致 Rank pos = find(rank); 中返回的 pos 实际指向一个无效的块位置。在 play 函数执行 char *cur = &get(pos); 时，代码试图访问未初始化的块内容或超出有效块范围的指针地址，从而引发 Runtime Error


## 构造思路
通过输入一个初始长度为 0 的字符串 a，并在最开始位置插入字符 A，测试代码是否正确处理空字符串的插入操作。由于插入操作会触发访问未初始化的块或越界块范围，测试在处理空字符串的边界情况时的鲁棒性

# 08.cpp

## 错误类型

Runtime Error


## 错误原因
play 函数中存在边界条件问题。当字符串 a 初始为空或者接近边界时，play 函数在处理 Rank l 和 Rank r 的边界扩展时会出现越界访问。具体而言，在 while 循环中，l.second < 0 或 r.second >= plen[r.first] 可能会导致对无效块或空块进行访问。对于输入 AA 和 0 A，rank=0 会导致 Rank pos 在 find 函数中定位到首块位置，之后访问的操作可能会导致越界，从而触发 segmentation fault 或 std::out_of_range 错误。



## 构造思路
输入 AA 和插入操作 0 A，会触发对空块的访问或导致越界，因为 play 函数未在边界位置正确检查块范围。这种情况下，消除操作在递归过程中会尝试访问无效的数组位置，触发运行时错误

# 09.cpp

## 错误类型
Runtime Error


## 错误原因
在play函数中，消除逻辑会在边界情况下导致越界访问。当输入初始字符串为AAA，并在位置0插入字符A时，字符串变为AAAA。代码会检测到连续的4个A需要消除，但在进行递归时，由于dis的更新和l.first或r.first块的调整逻辑不完善，程序会尝试访问空块或无效内存位置，导致段错误或越界访问，触发Runtime Error


## 构造思路
输入 AAA 和插入操作 0 A，构造一个连续四个相同字符的字符串，触发消除条件，测试代码在连续字符边界情况的处理。由于该情况会产生递归调用并尝试访问越界块，检测是否正确处理了分块消除逻辑

# 10.cpp

## 错误类型

Wrong Answer

## 错误原因
当输入字符串 AA 时，在索引 0 位置插入 A，得到字符串 AAA。play 函数应检测到连续三个相同的字符 A 并消除它们。然而，dis 和 eliminated 的更新逻辑没有正确触发连续字符的消除条件，因为 dis > 3 被误解为消除阈值（应为 dis >= 3），导致程序未能正确执行消除逻辑。此外，在 plen 数组的清零逻辑中，for (int i = l.first; i < r.first; i++) 会使中间块全部清零，即使没有完全消除，导致程序错误地修改块结构，最终产生错误的输出


## 构造思路

输入字符串 AA 和插入操作 0 A，形成三个连续的相同字符 AAA，期望代码能够正确检测到连续字符并执行消除操作。构造此测例的目的是验证程序是否能够正确处理最小的连续消除条件








