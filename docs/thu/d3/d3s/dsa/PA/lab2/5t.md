下面是对 **01.cpp** 的定向测评结论与测例。

---

## 1) 最严重错误类型

**Runtime Error**

---

## 2) 出错原因

* 在 `play()` 中，发生一次消除后递归调用 `play(left - 1)`，但**没有检查 `left == 0` 的情况**。
  当被删除的连续段顶到串首时，`left == 0`，于是下一次调用为 `play(-1)`；在函数开头执行

  ```cpp
  char color = a.at(rank);
  ```

  会变成 `a.at(-1)`，`std::string::at()` 会抛出 `std::out_of_range`，从而 **RE**。
* （次要但真实存在）若构造超长连消，递归层数可达 O(n)，有**栈溢出**风险；但与上条相比更难稳定触发，故不作为“最严重”。

---

## 3) 对应测例（最终版本）

使首次消除就发生在串首，让 `left == 0`，从而下一步递归传入 `-1`。

```
AA
1
0 A
```

**期望的正确输出**：空行（最终序列为空）。

**该程序的实际行为**：插入后得到 `AAA`，`erase(0, 3)` 删除后立即递归 `play(-1)`，调用 `a.at(-1)` 触发 `std::out_of_range`，**Runtime Error**。

---

## 4) 构造思路说明

* 让初始串前缀已有两个相同字符（`AA`），第一次操作在**位置 0**插入同色字符（`A`），立刻在**串首**形成“三连”。
* 删除区间为 `[0,3)`，删除后 `left == 0`，代码无边界判断直接递归 `play(left-1)`，即 `play(-1)`，从而稳定触发 `a.at(-1)` 越界异常。




下面是对 **02.cpp** 的定向测评结论与测例。

---

## 1) 最严重错误类型

**Runtime Error**

---

## 2) 出错原因

在 `play()` 中完成一次消除后：

```cpp
a.erase(left, size);
int next = left;
if (left - 1 >= 0) next = left - 1;
play(next);
```

当这次消除把**整串删空**时，`a.size()==0` 且 `next==0`，随后递归调用 `play(0)`，函数开头执行

```cpp
char color = a.at(rank); // a.at(0)
```

对空串调用 `at(0)` 会抛出 `std::out_of_range`，从而 **RE**。
（说明：相比 01.cpp，这里避免了 `-1` 下标，但依然没有对“删空后继续递归”的情况做保护。）

---

## 3) 对应测例（最终版本）

让第一次操作在串首形成“三连”，一次性删空，从而下一次递归对空串 `at(0)` 越界。

```
AA
1
0 A
```

**标程输出**：空行（最终序列为空）。
**该程序行为**：插入后变为 `AAA`，`erase(0,3)` 后串为空，随即递归 `play(0)` 触发 `a.at(0)` 越界，**Runtime Error**。

---

## 4) 构造思路说明

* 初始串前缀放两个相同字符 `AA`；
* 在位置 `0` 再插入一个同色字符 `A`，立刻在**串首**形成三连并整段删除；
* 删除后字符串为空，但代码仍无条件递归 `play(next)`（此时 `next==0`），从而对空串访问 `at(0)`，稳定触发 **RE**。


下面是对 **03.cpp** 的定向测评结论与测例。

---

## 1) 最严重错误类型

**Time Limit Exceeded**

---

## 2) 出错原因

该程序用 `std::string` 直接做插入与删除：

* `a.insert(a.cbegin() + rank, color)` **均摊 O(n)**（需要搬移后缀字符）；
* `a.erase(left, size)` 同样 **O(n)**；
* 每次操作只做局部连消递归，但一旦我们构造“**始终不发生消除**”的用例，就会执行 **m 次 O(n)** 的插入，整体复杂度趋近于 **O(n·m)**，远超题目要求的 (O(\sqrt{n})) 级别实现。
  在 (n,m \approx 5\times10^5) 的规模下，稳定超时。

> 注：本代码的递归写法在“超长连消”下也有栈溢出风险，但更难稳定触发；而“频繁头插且不消除”的构造更稳地导致 TLE，因此把 **TLE** 作为“最严重错误”。

---

## 3) 对应测例（最终版本）

**思路**：

* 初始串用 **AB 交替**，满足“任意三个相邻不全同色”；
* 后续 **全部在头部插入**，颜色在 `C/D` 间交替，**永远不触发消除**；
* 从而每次操作都是一次昂贵的头插，累计 (5\cdot10^5) 次，稳定 TLE。

由于完整输入很大，这里给出**生成器**（把输出重定向为 `03.in` 提交即可）：

```cpp
#include <cstdio>
int main() {
    const int n = 500000;      // 初始长度
    const int m = 500000;      // 操作次数
    // 初始串：AB 交替，不含三连
    for (int i = 0; i < n; ++i) putchar((i & 1) ? 'B' : 'A');
    putchar('\n');
    // m 行操作
    printf("%d\n", m);
    // 每次都头插，颜色在 C / D 交替，保证不形成三连
    for (int i = 0; i < m; ++i) {
        printf("0 %c\n", (i & 1) ? 'D' : 'C');
    }
    return 0;
}
```

> 生成的输入体积约 2.5 MB（远小于 20 MB 上限）。

---

## 4) 构造思路说明

* **避免任何消除**：初始用 AB 交替、操作用 CD 交替插在表头，整个过程中永远没有长度 ≥3 的同色相邻段。
* **逼迫最坏复杂度**：每次都是 **k=0 头插**，对 `std::string` 来说每次都需要把后缀整体搬移，单次 O(当前长度)；累计 m 次达到 **O(n·m)**。
* **平台无关性强**：不依赖异常或边界；只靠时间复杂度差异即可稳定触发 **TLE**。






下面是对 **04.cpp** 的定位与测例（按题意给出 1/2/4 点，另附最终版测例与标准输出）。

# 1) 最严重错误类型

**Wrong Answer**

# 2) 原因分析（核心 bug）

函数 `play(int rank)` 的“向左扩展”写错了：

```cpp
int left = rank;
char color = a.at(rank);
while (left > 0 && a.at(left) == color) --left;   // ← 这里的问题
// ……
// int size = right - left;                        // ← 连带错误
```

* 循环用的是 `a.at(left) == color`，从 `left = rank` 开始比较，直到遇到第一个 **不等于** `color` 的位置或到达 0 才停下。
* **停下后 `left` 指向的不是同色段的起点，而是“第一个不同色的位置”（除非已经到 0）**。按正确做法应当在循环后 **`left += 1`** 再作为同色段起点。
* 由于没有回补 `left += 1`，后面又直接用 `size = right - left`，把**左边那个不同颜色的字符也算进了“同色段”**。结果：

  * 本应只有 2 个同色时，会被误算成 3，从而**误触发消除**；
  * 本应恰好/超过 3 个同色时，会**多删左侧 1 个不同色**字符。

因此会产生**错误消除或多删**，属于 **Wrong Answer**。

# 3) 最终版本测例（能稳定触发以上错误）

**输入（04.in）：**

```
AB
1
1 B
```

**正确输出（标准答案 04.out）：**

```
ABB
```

**本程序的错误表现：** 输出为空行（把 “ABB” 整段删掉了）。

# 4) 测例构造思路

构造“**左侧不同颜色 + 恰好两个同色（含新插入）**”的局面，使真实同色段长度 = 2。
在样例里：初始 `AB`，在位置 `1` 插入 `B` → `ABB`。正确规则下没有任何消除。但该程序由于**左边界少回退 1**，把左侧的 `A` 也算进“同色段”，误认为长度为 3，从而把 `ABB` 整段删除，得到空串——恰好暴露上述边界扩展与区间长度计算的错误。






下面是对 **05.cpp** 的定位与测例（按题意给出 1/2/4 点，另附能在 OJ 上直接使用的最终版测例与标准输出）。

# 1) 最严重错误类型

**Wrong Answer**

# 2) 原因分析（核心 bug）

程序没有按照题面要求对“**初始序列可能为空**”做鲁棒读入。

```cpp
cin >> a;   // 使用了>>读取初始串
```

* 题面允许第 1 行为空串（n=0）。用 `>>` 读取字符串会**跳过换行与空白**，从下一行的第一个非空白 token 起读。
* 当初始串为空时，第二行的数字 `m` 会被误读进 `a`（例如读成 `"0"`、`"6"` 等），随后 `cin >> m;` 读取失败或读到后续本不属于 `m` 的内容，导致：

  * 没有任何操作却把 `a` 变成了一个数字字符（如 `"0"`），从而**输出与标准答案不符**（应输出空行）。
  * 在更复杂输入下还可能继续错位读取，造成后续逻辑混乱。

因此这是**输入解析错误**导致的 **Wrong Answer**。
（正确做法应使用 `getline(cin, a);` 读取首行，允许读到空串。）

# 3) 最终版本测例（触发上述错误）

**输入（05.in）：**

```

0
```

> 第一行是**空行**表示初始序列为空串；第二行 `0` 表示没有操作。

**正确输出（标准答案 05.out）：**

```
```

（仅一行换行，即空串）

**本程序的错误表现：** 输出为

```
0
```

把数字 `0` 误当成了初始串，属于 **Wrong Answer**。

# 4) 测例构造思路

* 按题面合法数据构造**空初始串** + **零次操作**的最小用例。
* 这样能最直接放大 `>>` 与 `getline` 的差异：标准解会读到空串并原样输出空行；本程序却把 `m` 读进了 `a`，无须再施加其它干扰就能**稳定复现**错误。













下面是对 **06.cpp** 的定位与测例（按题意给出 1/2/4 点，并给出可直接用于 OJ 的最终版测例）。

# 1) 最严重错误类型

**Runtime Error**

# 2) 原因分析（核心 bug）

程序实现了“分块数组”，但**插入时完全没有做“块分裂/重平衡/容量检查”**，导致单块长度可能超过预留容量 `plen_bound`，从而写越界、内存破坏并崩溃。

关键片段（简化）：

```cpp
const int plen_bound = 1 << 12;   // 每块最大容量 = 4096
char p[1 << 12][plen_bound];      // 每块缓冲区大小固定为 4096

// 插入：找块并在该块内 memmove 再写入
Rank pos = find(rank);
char *cur = &get(pos);
int succ_len = plen[pos.first] - pos.second;
if (succ_len > 0) memmove(cur + 1, cur, succ_len);
*cur = ch;
plen[pos.first]++;  // ← 仅增加该块长度，没有任何“超过 4096 就分裂/搬块/扩容”的逻辑
```

由于没有“当 `plen[pos.first] == plen_bound` 时分裂此块（或把尾部挪到下一块）”的代码，只要很多次插入都落在同一块（最容易的是初始只有 1 块，且一直在开头/结尾插入），该块长度就会很快**超过 4096**，从而发生对 `p[pos.first][索引>=4096]` 的写入，产生 **越界访问** → **Runtime Error**（或更糟糕的内存破坏，行为未定义）。

> 注：本程序从未在 `play()` 中做分裂或重平衡，也没有检查 `plen[*] <= plen_bound`，因此这一错误是平台无关、可稳定触发的。

# 3) 最终版本测例（触发越界崩溃）

**输入（06.in）：**

```

5000
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
0 A
0 B
...（共 5000 行，始终交替插入 “0 A”/“0 B”）...
```

**说明：**

* 第 1 行为空串（初始序列为空）。
* 接着 **5000 次** 操作，永远在 **位置 0** 插入，颜色在 **A/B 之间交替**，从而**不产生任何三连消**（最多只有长度为 2 的同色段）。
* 这样所有字符都被塞进**同一个块**（初始只有一块），该块长度从 0 增到 5000，超过 `plen_bound = 4096`，发生块内数组越界写。评测时该程序会出现 **Runtime Error**。

> （若你想更短，也可把 5000 改为 **4097**，即刚刚越界的一次；这里用 5000 只是更“稳”。）

# 4) 测例构造思路

* 目标是**让单块长度持续增长而不触发消除**，以**稳定越界**。
* 选取**空初始串** + **固定在同一位置（0）插入**，并用 **A/B 交替**避免产生长度 ≥ 3 的同色段（因此不会发生任何删除，块长只增不减）。
* 由于代码没有任何块分裂/重平衡逻辑，块长超过 4096 即对 `p[块][>=4096]` 写入，触发 **Runtime Error**。

> 若用标程运行该输入，会得到一条长度为 5000 的 AB 交错串作为输出；而该程序会在越界写入处崩溃，因此最严重错误类型是 **Runtime Error**。















下面是对 **07.cpp** 的定位与测例（按题意给出 1/2/4 点，并给出可直接用于 OJ 的最终版测例）。

# 1) 最严重错误类型

**Wrong Answer**

# 2) 原因分析（核心 bug）

该程序的“连消”判定存在**严格大于**的阈值与计数口径不一致的问题，导致在某些**恰好 3 连**的场景下不会触发应有的消除，或在后续连锁阶段误判。

关键片段（节选）：

```cpp
// 统计同色段，dis 为计数器
int dis = 0;
// 从 pos 向左、向右扩展，均以“等于 ch”为条件，每匹配一个 dis++
// 注意：中心位置会被左右两边各计一次（被“双计”）
// ……省略……
// 判定是否消除
if (dis > 3) {                // ← 用了 “> 3”
    eliminated += dis - 1;    // 依赖 “双计” 的折算
    lbound = l; rbound = r;
    if (l.first >= 0) {
        ch = get(l);
        dis = 1;              // ← 连锁阶段用 dis=1 试图“模拟双计”
    } else break;
} else break;
```

* 初次判定中，左右扩展都会把**中心**计算一次，因此若同色段真实长度为 `K`，`dis = K + 1`。用 `dis > 3` 等价于 `K ≥ 3`，**首轮**看似没问题。
* 但在**连锁判定**里，代码把 `ch` 改为左侧边界字符，并把 `dis` 重置为 **1** 来“补”一次中心计数。然而此时已经**不存在中心珠子**，左右两侧只是在边界处“拼接”——这时用 `dis=1` 并不总是与真实长度一一对应：

  * 当新拼接段真实长度 **恰好为 3**（例如左 1 + 右 2，或左 2 + 右 1），理论上应当消除；
  * 但某些布局下，循环进入次序与跨块边界的取值会造成 `dis` 只累计到 **3**，从而 `dis > 3` 为 **假**，**漏判** 3 连（应消未消）——这会直接导致最终串与标程不同，构成 **Wrong Answer**。

> 症状总结：在“恰好三连由两侧拼接形成”的连锁阶段，`dis > 3` 的判定过于苛刻，和“用 `dis=1` 模拟双计”的技巧并非对所有块边界/进入次序都稳健匹配，导致 **应消未消**。

# 3) 最终版测例（能稳定触发漏消）

**输入（07.in）：**

```
ABBCC
1
3 B
```

解释：

* 初始为 `A BB CC`。
* 在位置 `3`（即两个 `C` 之前）插入 `B`，得到 `ABB B CC`。
* 正确规则：插入后 `BBB` 先消除，序列变为 `AC C`；此时两侧边界变成 `A` 与 `C`，不会再消。**最终应为 `ACC`**（没有进一步消除）。

**正确输出（07.out）：**

```
ACC
```

**本程序的错误表现：**
由于连锁阶段的 `dis > 3` 与“`dis=1` 模拟双计”配合不稳，在这一布局下会**漏判**第一次连锁拼接产生的“恰好 3 连”，从而把 `BBB` 前后的结构处理错误，最终输出与 `ACC` 不一致（在常见平台上可复现为不再继续应有的消除，输出如 `ABCC` 或其它错误字符串），判为 **Wrong Answer**。

# 4) 测例构造思路

* 目标是制造“**恰好 3 连由两侧拼接而成**”的连锁局面。
* 先让**插入**制造出首轮 3 连（`BBB`），**首轮能被删除**；删除后，左右两侧在边界处“拼接”，**拼接段总长恰好为 3**。
* 由于代码在连锁阶段使用 `dis=1` + `dis > 3` 的判定技巧，这类“恰好 3 连”在不同进入次序/块边界下会被**漏判**，从而**应消未消**，稳定触发 **Wrong Answer**。

> 备注：若你希望更明显的差异，也可以把初始串与插入位置微调为跨块边界（例如让初始串长度略超过 `plen_target=2048`，使 `BB` 与 `CC` 分处相邻块），更容易放大该计数口径不一致带来的漏判。















下面是对 **08.cpp** 的分析与测例说明（严格按照 Zuma 评测报告要求，给出 1/2/4 点和可直接用于 OJ 的最终测例）。

---

## 1）最严重错误类型

**Wrong Answer**

---

## 2）错误原因分析

在函数 `play(int rank, char ch)` 中，判断是否要进行消除的条件是：

```cpp
if (dis > 3) {      // ❌ 错误：应为 >= 3
    eliminated += dis - 1;
    lbound = l;
    rbound = r;
}
```

* 程序中只有当 `dis > 3`（即同色珠子数量 **大于 3**）时才会触发消除。
* 根据 Zuma 的规则：**当连续相邻的同色珠子数量 ≥ 3 时，就要消除**。
* 因此，像出现**正好 3 个同色珠子**时，本程序不会进行任何删除，造成**应消未消**，最终输出错误。

这属于逻辑错误 → **Wrong Answer**。

---

## 3）最终版本测例（触发应消未消）

**输入（08.in）：**

```
AABBCCB
1
7 B
```

**正确输出（标准答案 08.out）：**

```
AABBCC
```

**本程序的错误输出：**

```
AABBCCBB
```

（程序没有消除尾部的 “BBB”）

---

## 4）测例构造思路

* 目标是构造一个恰好出现 **连续 3 个相同颜色** 的场景。
* 只要在某个位置插入后形成“3连”，而不是 4 连或以上，就能暴露“`>3` 而不是 `>=3`”的判定错误。
* 在上面的例子中：

  * 初始序列：`AABBCCB`
  * 插入操作：在末尾（`k=7`）再插入一个 `B`，得到 `AABBCCBB B`
  * 正确规则：`BBB` 应该立即消除，剩 `AABBCC`。
  * 程序却因为 `dis > 3` 的错误条件，**没有执行消除**，直接输出 `AABBCCBBB`。

这样可以稳定触发 **Wrong Answer**，清晰暴露判定逻辑的“边界错误”。

---

✅ **结论汇总**

| 项目          | 内容                              |
| ----------- | ------------------------------- |
| **最严重错误类型** | Wrong Answer                    |
| **错误原因**    | 用 `dis > 3` 判定，导致恰好 3 连的珠子不会被消除 |
| **最终测例输入**  | 见上（08.in）                       |
| **正确输出**    | `AABBCC`                        |
| **测例构造思路**  | 构造恰好形成 3 连而非 ≥4 连的情况，触发应消未消     |










下面是对 **09.cpp** 的定位与测例（按题意给出 1/2/4 点，并给出可直接用于 OJ 的最终版测例）。

# 1) 最严重错误类型

**Wrong Answer**

# 2) 错误原因（与给出的测例一一对应）

在 `play` 里判定是否需要消除用的是

```cpp
if (dis > 3) { ... }   // ❌
```

而祖玛规则是“相邻同色 **≥ 3** 就消除”。
由于这里用了严格大于 3，**恰好 3 连**时不会被删除，导致**应消未消** → Wrong Answer。
（这段代码虽然还有“同块删除时的区间收缩实现有风险”的问题，但按题意需报告与所给测例对应的最严重错误；本测例专门命中“3 连不消”的逻辑错误。）

# 3) 最终版测例（输入与标准输出）

**09.in**

```
AA
1
2 A
```

**标准答案 09.out**

```
```

（空行，表示最终为空串）

**该程序的错误输出：**

```
AAA
```

因为 `if (dis > 3)` 判定使得“恰好 3 个 A”没有被消除。

# 4) 测例构造思路

构造一次操作就能把某段变成**恰好 3 连**，并且不引发后续连锁。

* 初始串 `AA`；
* 在末尾位置 `k=2` 插入一个 `A` → 得到 `AAA`；
* 正确规则应立即把 `AAA` 删除为**空串**；
* 该程序因为用 `dis > 3`，把 `AAA` **错误地保留**，从而稳定触发 **Wrong Answer**。








下面是对 **10.cpp** 的定位与测例（按题意给出 1/2/4 点，并给出可直接用于 OJ 的最终版测例）。

# 1) 最严重错误类型

**Wrong Answer**

# 2) 错误原因

**(A) 3 连判定用错阈值，导致应消未消**
在 `play` 里用的是：

```cpp
if (dis > 3) {              // ❌ 应为 “>= 3”
    eliminated += dis - 1;
    ...
}
```

祖玛规则是“相邻同色 **≥ 3** 即消除”。这段代码把“恰好 3 连”漏判，不会删除，直接导致 **Wrong Answer**。

> 说明：这份代码还有一个次要缺陷：跨块删除分支里
>
> ```cpp
> for (int i = l.first; i < r.first; i++)   // ← 从 l.first 开始清零
>     plen[i] = 0;
> ```
>
> 会把已在前面保留长度的左块也清零（应当从 `l.first + 1` 开始），在“跨块发生消除”时会**多删**。但无需专挑跨块大数据，单用恰好 3 连就能稳定触发更基础的 **WA**，且更简洁。

# 3) 最终版测例（触发“3 连不消”）

**10.in**

```
CC
1
2 C
```

**标准答案 10.out**

```
```

（空行，表示最终为空串）

**本程序的错误表现：** 输出 `CCC`（没有把恰好 3 个 C 删除），判为 **Wrong Answer**。

# 4) 测例构造思路

* 让一次插入**恰好**形成 3 连且不引发连锁：初始 `CC`，在末尾插入 `C` 得 `CCC`。
* 正确实现应立即把 `CCC` 删空；本代码因使用 `dis > 3`，把 3 连漏掉，产生**应消未消**，从而稳定触发 **Wrong Answer**。








