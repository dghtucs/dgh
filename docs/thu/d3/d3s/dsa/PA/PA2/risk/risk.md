risk

## 算法思路和实现要点

用单调队列（Max Queue）在一次线性扫描中求出每天“向前 (m_i) 天（不含当天）”的最大值 (K_i)。具体做法：按天递增遍历，窗口左端为 (L=i-m_i)。先把队首（保存的是下标）凡是小于 (L) 的弹出；此时队首值即为窗口最大值，若队列为空则 (K_i=0)。随后将当天 (x_i) 入队：从队尾删去所有不大于 (x_i) 的元素，再压入 ((i,x_i))。同时用计数数组对每个 (K_i) 计数。扫描结束对计数做前缀和；对任意查询 ((p,q))，低风险为 (#{K_i<p})，中风险为 (#{K_i<q}-#{K_i<p})。实现细节：仅用 `scanf/printf`，不使用 STL；注意窗口不含当天、`m_i` 为 32 位需用 64 位计算 (L)，并对 (p-1,q-1) 越界作“截到最大值”的处理。

## 渐进时间复杂度的分析，包含过程

每个下标仅在单调队列中入队一次、出队至多一次，故整段“滑窗求最大值”是 (O(n))。在求出全部 (K_i) 的同时完成计数，随后对计数数组做一次前缀和，复杂度为 (O(\mathrm{maxX}))，其中 (\mathrm{maxX}=\max x_i \le 2\times10^6)。每个查询只需 (O(1)) 读取两次前缀和并作一次差。综合得到总时间复杂度
[
T(n,T_q)=O\big(n+\mathrm{maxX}+T_q\big),
]
当问题规模（天数与查询数）趋大时，整体耗时呈线性增长。

## 渐进空间复杂度的分析，包含过程

（不计输入/输出数据本身的存储）
辅助空间包含：单调队列的两个数组（下标与值）大小均为 (O(n))；统计 (K_i) 的计数数组及其原地前缀和为 (O(\mathrm{maxX}))。因此总辅助空间复杂度为
[
S(n)=O\big(n+\mathrm{maxX}\big).
]
在极限数据（(n=10^6,\ \mathrm{maxX}=2\times10^6)）下，整数数组总量约为 ((2n+\mathrm{maxX})) 个 `int`，即约 (4\times10^6) 个整数，约 16 MB，满足 256 MB 限制。

## 遇到的困难和解决方法

* 窗口边界易错：题意为“前 (m_i) 天，不含当天”，实现时先取最大值再入队当天，或严格用下标维护窗口为 ([i-m_i,,i-1])。
* `m_i` 为无符号 32 位，计算 (L=i-m_i) 需转为 64 位避免下溢。
* 查询阈值可能超过 (\mathrm{maxX})，前缀和下标需截断到 (\mathrm{maxX})。
* 大数据读写：仅用 `scanf/printf` 并避免多余输出；线性算法保障通过时限。
  （其余：不使用 STL，改为手写数组队列与计数前缀和。）

## 估计完成本题所用时间

1.5 小时

## 关于本题的更多感想

这题是“可变窗口的滑动最大值 + 多次离线计数查询”的典型组合。利用题目提供的 (m_i \le m_{i-1}+1) 可知左端点单调不减，天然适配单调队列在线维护；再配合值域不大的前缀和，查询退化为 (O(1))。整体思路清爽、实现细节需谨慎。
