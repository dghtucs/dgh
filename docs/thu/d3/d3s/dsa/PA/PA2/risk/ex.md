## 算法思路和实现要点

对每天的确诊病例数进行统计，并根据过去 `mi[i]` 天内的最大确诊病例数来划分风险等级。具体算法思路如下：

1. 计算每日的最大值 `k[i]`：对于每一天 `i`，需要找到过去 `mi[i]` 天（不包括当天）内的最大确诊病例数 `xi[j]`，即 `k[i] = max{ xi[j] | j ∈ [i - mi[i], i - 1] }`。为高效计算滑动窗口的最大值，使用了一个自定义的双端队列 `Deque`，在 `O(n)` 时间内完成所有 `k[i]` 的计算。

2. 统计每个可能的 `k[i]` 值出现的次数：使用计数数组 `cnt[k[i]]` 来统计每个可能的 `k[i]` 值出现的次数。

3. 构建前缀和数组 `sum[k]`：为了快速计算区间内的天数，构建了前缀和数组 `sum[k]`，其中 `sum[k]` 表示 `k` 以下的所有 `k[i]` 值的总出现次数。

4. 处理查询：对于每个查询 `(p, q)`，利用前缀和数组快速计算低风险（`k[i] < p`）和中风险（`p ≤ k[i] < q`）的天数。

实现要点包括：

- 双端队列的实现：动实现了一个支持必要操作的双端队列，以维护滑动窗口的最大值。

- 高效的统计方法：通过前缀和数组，将每个查询的时间复杂度降低到 `O(1)`。

## 渐进时间复杂度的分析

- 读取输入数据：读取 `n` 个 `xi` 和 `mi`，时间复杂度为 `O(n)`。

- 计算每日的最大值 `k[i]`：每个元素最多被加入和移除队列一次，故总时间复杂度为 `O(n)`。

- 统计 `k[i]` 的出现次数：遍历 `k[i]` 数组，时间复杂度为 `O(n)`。

- 构建前缀和数组 `sum[k]`：数组大小为 `MAX_XI`（约为 `2e6`），时间复杂度为 `O(MAX_XI)`。

- 处理查询：每个查询的时间复杂度为 `O(1)`，总共 `T` 个查询，时间复杂度为 `O(T)`。

综上，总时间复杂度为 `O(n + MAX_XI + T)`。由于 `MAX_XI` 是常数级别，故主要时间消耗在 `O(n + T)`。

## 渐进空间复杂度的分析

- 存储输入数据：`xi[0..n]` 和 `mi[1..n]`，空间复杂度为 `O(n)`。

- 双端队列：最多存储 `n` 个元素，空间复杂度为 `O(n)`。

- 统计数组：`cnt[0..MAX_XI]` 和 `sum[0..MAX_XI]`，空间复杂度为 `O(MAX_XI)`。



总空间复杂度为 `O(n + MAX_XI)`。由于 `MAX_XI` 是常数级别，故整体空间复杂度为 `O(n)`。

## 遇到的困难和解决方法

- 需要手动实现双端队列。

- 边界条件处理：确保在滑动窗口移动时，正确移除过期的元素，防止数组下标越界。

- 大数据量下的效率：需要优化算法，使其在数据量较大时仍能在时间和空间限制内运行

## 估计完成本题所用时间 

6 小时

