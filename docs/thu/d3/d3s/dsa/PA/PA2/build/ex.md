## 算法思路和实现要点

本题要求对一棵由 N 个节点构成的多叉树进行子树移动和查询

算法思路：

- 树的存储： 使用孩子兄弟表示法，通过数组 `parent`、`first_child`、`next_sibling` 存储多叉树结构。

- 祖先关系判断： 为了高效判断节点之间的祖先关系，使用 时间戳（Euler Tour Technique）。在对树进行深度优先遍历时，为每个节点分配进入时间 `tin[u]` 和离开时间 `tout[u]`，从而可以在  O(1)  时间内判断一个节点是否是另一个节点的祖先或后代。

- 规模和高度维护： 对于每个节点，维护其子树的规模 `size[u]` 和高度 `height[u]`。在移动操作后，需要更新受影响的节点的这些信息。

- 移动操作：

  - 防止形成环： 利用时间戳判断祖先关系，避免在移动过程中形成环。

  - 更新节点信息： 在移动子树时，更新受影响节点的 `size`、`height`、`depth`、`tin`、`tout` 信息，确保数据一致性。

- 查询操作： 直接输出所查询节点的规模或高度，无需额外计算。

实现要点：

- 高效更新： 确保在移动操作后，所有受影响的节点的信息都被正确更新，避免错误的查询结果。

- 模拟栈避免递归： 在更新深度和时间戳时，使用模拟栈的方法代替递归，防止因递归层数过深导致的栈溢出。

- 输入输出优化： 使用 `scanf` 和 `printf` 进行高效的输入输出，满足时间要求。

## 渐进时间复杂度的分析，包含过程

- 初始化：

  - 对整棵树进行一次深度优先遍历，计算每个节点的 `size`、`height`、`depth`、`tin`、`tout`，时间复杂度为 \( O(N) \)。

- 移动操作：

  - 祖先关系判断： 使用时间戳在 \( O(1) \) 时间内判断祖先关系。

  - 更新节点信息：

    - 更新被移动子树中所有节点的深度和时间戳，时间复杂度为 \( O(\text{子树大小}) \)。

    - 从被移动子树的新旧父节点向上更新 `size` 和 `height`，最坏情况下时间复杂度为 \( O(\log N) \)，因为树的高度有限。

- 查询操作：

  - 读取通路表示法并找到对应节点，时间复杂度与通路长度有关，且操作成本有限。

- 总时间复杂度：

  - 由于所有操作的总成本不超过 \( 10^6 \)，且 \( N \leq 10^6 \)，因此总的时间复杂度为 \( O(N + \text{total\_cost}) \)，满足时间限制。

## 渐进空间复杂度的分析，包含过程

- 数组存储：

  - 使用大小为 \( O(N) \) 的数组存储树的结构和节点信息，包括 `parent`、`first_child`、`next_sibling`、`size`、`height`、`depth`、`tin`、`tout`。

- 辅助栈：

  - 在更新深度和时间戳时，使用了一个模拟栈，最坏情况下栈的大小为 \( O(N) \)。

- 总空间复杂度：

  - 除了存储输入输出所需的空间，程序的总空间复杂度为 \( O(N) \)，符合空间限制要求。

## 遇到的困难和解决方法

- 困难：

  - 初始实现中，为了避免超时，对更新操作进行了限制，导致部分节点信息未正确更新，产生错误的查询结果。

- 解决方法：

  - 取消更新操作的限制，确保每次移动后，所有受影响的节点都被正确更新。

  - 使用时间戳技术优化祖先关系判断，提高判断效率。

## 估计完成本题所用时间

大约 6 小时。

