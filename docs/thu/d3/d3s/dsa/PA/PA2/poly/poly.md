poly
## 算法思路和实现要点

用“中缀表达式两栈法”在线求值：一个操作符栈、一个多项式栈。按字符扫描，支持 `+ - * ^ ( )`，并按题意在遇到 `(` 或 `x`（且左侧不是 `x`）时**注入隐式乘号**。优先级 `^ > * > + -`，且 `^` **左结合**，据此用“>=”规则出栈。
多项式采用三态表示：常数、单项式（(c\cdot x^d)）、一般式（长度 65 的系数数组，最高次数 ≤64）。运算时尽量在常数/单项式层面闭包，只有必要时才升为一般式，降低内存与常数因子。幂的指数为正整数字面量（且 ≤4），用小幂连乘。所有系数在 (M=10^9+7) 下取模，乘法用 `__int128` 防溢出；输出时去除模后最高位为 0 的项。

## 渐进时间复杂度的分析，包含过程

设输入长度为 (L)，加减次数为 (a)，乘号为 (b)，幂号为 (c)，令 (D) 为最高次数上界（≤64）。
逐字符扫描与压栈/出栈为 (O(L))。
多项式运算代价：

* 加/减：合并系数，(O(D))；
* 乘法：卷积，(O(D^2))；
* 幂：因 (k\le4)，至多常数次乘法，仍为 (O(D^2))。
  故总复杂度为
  [
  O\big(L + aD + (b+c)D^2\big).
  ]
  由于 (D) 为常数（≤64），当问题规模（输入长度、运算个数）增大时，整体时间呈**线性**增长：(,O(L))。

## 渐进空间复杂度的分析，包含过程

不计输入/输出缓存。算法使用：

* 操作符栈：最多 (O(L))；
* 值栈：存放多项式“头部信息”（常数/单项式极小），当升为一般式时需一个长度 (D+1) 的数组。
  在任意时刻，同时存活的一般式数量不超过栈深，故辅助空间为
  [
  O\big(L + sD\big),
  ]
  其中 (s) 为一般式的同时在栈个数；以 (D) 常数和典型栈深有限为前提，整体可视为 **(O(L))**。此外每次合并后及时释放中间数组，控制峰值。

## 遇到的困难和解决方法

1. `^` 为**左结合**与常见语言相反，出栈条件改为 `>=` 以符合题意；
2. 隐式乘号易漏，按上下文在 `(`、`x` 前注入 `*` 并重走当前字符；
3. 系数可能很大，乘法用 `__int128` 并统一取模；
4. 结果需去前导零，合并后动态降型（一般式→单项式/常数）以减少内存；
5. 幂的右操作数必须是正整数字面量，解析时严格限制。

## 估计完成本题所用时间

3 小时

## 关于本题的更多感想

把多项式做“分层表示”（常数/单项式/一般式）能显著降低常数因子；再结合左结合幂与隐式乘号的细节处理，线性扫描即可完成中缀求值。度数上界与小幂约束让卷积成本可控，是工程与题设约束良性交织的典型一题。
