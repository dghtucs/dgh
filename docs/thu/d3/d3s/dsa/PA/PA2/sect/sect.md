sect
## 算法思路和实现要点

把树按“允许向上追溯”的规则收缩成若干条**传承链**。做法：① 用**非递归后序遍历**在线性时间求每个节点子树内力和 `subsum`；② 对每个父亲，按“子树和最大，和相同取编号小”的规则确定**正统弟子** `heir`。若父仅一子，该子天然可向上；否则仅 `heir` 可向上。由此得到每点最多一条向上的边 `up[v]=parent`，并形成若干条链；③ 对每条链从链头到链尾扫描，维护**严格递减**的单调栈，求出“左侧最近更大”（即第一个内力更强的前辈）。注意 `subsum` 需用 64 位整型。

## 渐进时间复杂度的分析，包含过程

设节点数为 (N)。

* 非递归后序遍历统计 `subsum`：每条边访问常数次，(O(N))；
* 为每个父亲选正统弟子：线性扫描其孩子，总计 (O(N))；
* 构造 `up/down`：(O(N))；
* 每条链上单调栈求最近更大：每点至多入栈出栈一次，合计 (O(N))。
  综上，总时间复杂度为 (O(N))，当 (N) 增大时用时线性增长。

## 渐进空间复杂度的分析，包含过程

不计输入/输出本身，算法使用：`parent、cnt、pos、subsum、heir、up、down、ans` 等若干整型/长整型数组各为 (O(N))，以及后序遍历栈与链上单调栈合计 (O(N))。因此总辅助空间复杂度为 (O(N))。其中 `subsum` 采用 64 位以防止子树和溢出。

## 遇到的困难和解决方法

* **后序顺序**易错：改为显式栈记录“下一孩子索引”，确保“先子后父”。
* **正统弟子判定**：比较子树和，和相同取编号小，避免遗漏边界。
* **链上方向**：必须从链头向下做“左侧最近更大”。
* **数值溢出**：`a_i≤1e9`，`subsum` 最高可达 (1e15)，用 `unsigned long long`。

## 估计完成本题所用时间

1.5 小时

## 关于本题的更多感想

把“可向上追溯”的判定提前固化为链结构，是把树上问题化简为序列问题的关键；随后用单调栈解“最近更大”水到渠成。实现上最容易翻车的是后序与细节边界，理清时序即可稳过。
