
# BBST 性能对比实验报告



---

## 1. 数据结构的实现过程及复杂度分析

本实验中我选取了 AVL树 和 Splay树 两种经典的自平衡二叉搜索树进行实现。

### 1.1 AVL 树
   实现过程：
    采用了经典的递归方式实现。在每个节点 `Node` 结构体中维护 `height` 属性。
    1.  插入与删除：执行标准的 BST 插入/删除操作。
    2.  高度更新与平衡：在递归回溯过程中，更新路径上节点的高度。若发现某个节点的平衡因子（左右子树高度差）绝对值 $|BF| > 1$，则根据失衡类型进行相应的单旋（LL/RR）或双旋（LR/RL）。
    3.  查找操作：针对题目要求的“查找 $\le x$ 的最大值”，在 BST 搜索过程中记录遇到的所有 $\le x$ 的节点中的最大者，不改变树结构。

   复杂度分析：
    AVL 树通过旋转严格维持树的高度在 $O(\log n)$ 级别。
       时间复杂度：插入、删除、查找的最坏情况均为 $O(\log n)$。
       空间复杂度：$O(n)$ 用于存储节点。

### 1.2 Splay 树
   实现过程：
    为了优化性能并防止递归造成的栈溢出，采用了 Top-Down（自顶向下）迭代式 实现。
    1.  核心 Splay 操作：摒弃了传统的从底向上旋转。在从根向下搜索目标 key 的过程中，使用 `LeftTreeMax` 和 `RightTreeMin` 两个临时树桩，将遇到的节点根据大小关系拆分挂接到这两棵临时树上（Three-way Join）。当搜索结束时，再将左、中、右三部分重新组装。
    2.  插入/删除/查找：所有操作均以 Splay 操作为基础。操作完成后，目标节点（或最接近的节点）会被移动到树根。

   复杂度分析：
    
时间复杂度：单次操作最坏为 $O(n)$，但均摊时间复杂度为 $O(\log n)$。
    空间复杂度：$O(n)$，且相比 AVL 树节省了 `height` 字段的空间。

---

## 2. 设计测例的思路

为了全面评估不同数据结构在不同应用场景下的表现，我设计了三种具有代表性的数据分布模式：

1.  基准性能测试：使用完全随机的数据，模拟通用的、无特定规律的负载，检验树在一般情况下的平衡能力。
2.  最坏情况/时序数据测试：使用严格单调递增的数据。这对普通 BST 来说会让他们退化为链，来测试 Splay 树处理“长链”和 AVL 树应对频繁旋转的能力。
3.  缓存/热点数据测试：利用局部性原理（Locality of Reference），模拟真实世界中“少量数据被频繁访问”的场景，检验 Splay 树的动态调整优势。

---

## 3. 测例如何生成

我编写了 `generator.py` 脚本，生成规模 $N=500,000$ 的指令序列文件。

1.  Random (随机数据)：
       利用 `random.choice` 随机选择 `A` (插入), `B` (删除), `C` (查找) 操作。
       操作数 $x$ 在 $[0, 8500000]$ 范围内均匀随机选取。

2.  Sequential (顺序数据)：
       先生成 250,000 条插入指令：`A 0`, `A 2`, `A 4` ... （单调递增）。
       后生成 250,000 条查找指令：`C 1`, `C 3`, `C 5` ... （单调递增）。

3.  Locality (局部性数据)：
       维护一个“热点集合”。
       生成指令时，设定 80% 的概率 从热点集合中选取操作数（模拟频繁访问），20% 的概率 随机生成新数（模拟冷数据）。模拟了时间局部性。

---

## 4. 不同数据结构在不同测例下的性能描述及原因分析

下表总结了两种数据结构在三种测例下的运行时间

| 测例类型 | AVL 树耗时 (s) | Splay 树耗时 (s) | 性能对比 |
| :--- | :--- | :--- | :--- |
| Random | 0.503 | 0.564 | AVL 略优 |
| Sequential | 0.416 | 0.353 | Splay 优 |
| Locality | 0.523 | 0.386 | Splay 显著优 |

### 原因详细分析：

1.  Random (随机数据)：
       现象：AVL 树比 Splay 树稍快（约快 10%）。
       分析：在完全随机的数据流下，AVL 树凭借严格的高度控制（树高约为 $1.44 \log n$），保证了查找路径最短。而 Splay 树虽然也维持了 $O(\log n)$ 的均摊性能，但每次操作都会强制触发树的重构（Splay 操作），导致常数项开销略大于仅仅读取数据的 AVL 查找。

2.  Sequential (顺序数据)：
       现象：Splay 树反超 AVL 树。
       分析：顺序插入会导致树倾向于向一边倾斜。AVL 树为了维持严格高度平衡，必须频繁执行旋转操作。相比之下，Top-Down Splay 在处理单调序列时表现出了惊人的效率——顺序插入形成的链状结构在访问时会被极其高效地折叠，且后续的顺序访问通常发生在树的浅层，均摊代价极低（接近 $O(1)$）。
       

3.  Locality (局部性数据)：
       现象：Splay 树大幅领先，耗时减少约 26%。
       分析：这是 Splay 树设计的核心优势领域。Splay 的 "Move-to-Root" 策略将最近访问的热点节点一直维持在根节点附近。对于热点数据的后续重复访问，Splay 树几乎瞬间完成。反观 AVL 树，它对数据的访问频率无感知，访问热点节点仍需走完 $O(\log n)$ 的路径，造成了性能浪费。

总结：如果应用场景对单次最坏响应时间有严格要求且数据无规律，AVL树更佳；如果应用场景存在明显的时间局部性（如缓存、文本编辑），Splay树则能显著提升性能。