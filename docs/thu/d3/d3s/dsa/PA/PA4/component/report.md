## 算法思路和实现要点

用左式堆实现一个**小根堆**：堆内始终保留该块点权最大的 $k$ 个值，则堆顶（最小）就是第 $k$ 大。初始化时每个点自成块，堆仅含自身点权。合并两块时：先 DSU 按块大小合并父亲，再把两块的小根堆用左式堆 `merge` 合并，同时维护堆大小 `heapSz`；若合并后 `heapSz>k`，反复 `pop` 删除堆顶（最小）直到大小为 $k$。查询时找到 $u$ 的根：若真实块大小 `compSz<k` 输出 $-1$，否则输出堆顶权值。允许自环/重边，DSU 发现同根直接跳过即可。

## 渐进时间复杂度的分析，包含过程

设点数 $n$，操作数 $q$，初始边数 $m$。并查集 `find` 均摊为 $O(\alpha(n))$。左式堆合并一次 `merge` 的均摊复杂度为 $O(\log s)$（$s$ 为堆大小），`pop` 也是 $O(\log s)$。每次合并连通块会执行一次堆合并，并可能执行若干次 `pop` 以保持堆大小不超过 $k$。注意每个点权一旦被 `pop` 删除，之后不会再进入任何块的 top-$k$，因此全程被删除的次数总计不超过 $n$。故总时间近似为
$$O((m+q)\alpha(n) + (m+q)\log n + n\log n),$$
可简化为
$$O((m+q)\log n).$$

## 渐进空间复杂度的分析，包含过程

额外空间主要为：并查集数组 `fa, compSz` 共 $O(n)$；每块堆根与堆大小 `heapRoot, heapSz` 共 $O(n)$；左式堆节点数组 `L,R,dist,key` 每点一个节点，共 $O(n)$；输出缓冲为常数级。所以整体额外空间为
$$O(n).$$

## 遇到的困难和解决方法

1）需要支持“连通块第 $k$ 大”且动态合并：用“维护 top-$k$”的思路，把问题转为维护一个大小不超过 $k$ 的小根堆，堆顶即答案。
2）合并时若直接保留所有点权会爆内存/超时：合并后立即把堆缩到 $k$，并利用“被删元素不可能再回来”的性质控制总 `pop` 次数。
3）数据规模大：使用 `fread` 快读与输出缓冲，避免 `cin/cout` 成为瓶颈。

## 估计完成本题所用时间

3 小时
