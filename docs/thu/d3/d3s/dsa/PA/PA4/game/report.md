## 算法思路和实现要点

由于所有通关时间 $t[i]>0$，若选择的通关集合含有从1到N的路径之外的分支关卡，只会增加总时间而不帮助更快到达N，因此最短通关一定对应一条从1到N的简单路径。于是问题转化为：在无向图中求从1到N的“点权最短路”及其条数。设 $dist[u]$ 为从1到u的最小点权和，则转移为
$$dist[v]=dist[u]+t[v]$$
初始化 $dist[1]=t[1]$。用手写小根堆实现 Dijkstra：每次取当前 $dist$ 最小的点松弛邻边。方案数 $ways[u]$：若得到更小距离则令 $ways[v]=ways[u]$；若得到相同距离则
$$ways[v]=(ways[v]+ways[u])\bmod (10^9+7).$$

## 渐进时间复杂度的分析，包含过程

设点数为 $N$，边数为 $M$。Dijkstra 过程中，每条边在松弛时最多触发一次“有效更新”（更小）和若干次“相等更新”，但每次尝试松弛是沿邻接表扫描产生的，总扫描次数为 $2M$ 量级。每次更小更新会执行一次入堆，入堆与出堆的堆调整代价为 $O(\log H)$，其中堆规模 $H$ 不超过入堆次数，量级为 $O(M)$。因此总时间为
$$O((N+M)\log M),$$


## 渐进空间复杂度的分析，包含过程

除去输入输出本身，主要额外空间包括：邻接表数组 `to/nxt/head` 共 $O(N+M)$；最短路数组 `dist/ways/vis` 共 $O(N)$；手写堆数组容量按 $O(M)$ 预留。故额外空间总计
$$O(N+M).$$


## 遇到的困难和解决方法

1）需要证明最短通关不必包含分支：利用 $t[i]>0$，任何离开1到N路径的额外关卡都会严格增加时间，因此最优可化简为路径。
2）为避免“重复状态”影响正确性，用 `if (d!=dist[u]) continue` 丢弃旧堆元素。

## 估计完成本题所用时间

2.5 小时

