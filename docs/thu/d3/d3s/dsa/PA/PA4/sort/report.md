## 算法思路和实现要点

题目只能用三元比较器 compare(a,b,c) 返回最小和最大。整体采用“先找全局最小哨兵 + 归并排序”的框架。先用多轮“三取一最小晋级”在 $O(n)$ 次 compare 内得到全局最小编号 $min$，作为后续二元比较的哨兵：比较 $u,v$ 时调用 compare(u,v,min)，因 $min$ 为全局最小，返回的最大值即 $\max(u,v)$，从而判断 $u<v$。排序阶段先对长度为 TH 的小块做插入排序，再自底向上归并。归并时利用三元比较器一次处理两步：当左段至少两个元素 $x_1<x_2$，与右段首元素 $y_1$ 比较 compare($x_1,x_2,y_1$)，可根据返回的 min/max 判断三者相对位置，从而一次输出 1~2 个元素，减少 compare 次数；边界退化为用哨兵做二元比较。调试痕迹用宏 `-DDEBUG` 输出比较次数与阶段信息。

## 渐进时间复杂度的分析，包含过程

找全局最小：每轮把 3 个元素压成 1 个最小值，元素数约乘 $\frac{1}{3}$，比较次数为
$$\left\lfloor\frac{n}{3}\right\rfloor+\left\lfloor\frac{n}{9}\right\rfloor+\cdots=O(n).$$
排序主体为归并排序：共有 $\lceil \log_2(n/TH)\rceil$ 轮合并，每轮线性扫描全数组。优化合并中，一次 compare 可能输出 1~2 个元素，但渐进上仍是线性级别，因此单轮为 $O(n)$，总计
$$O(n\log n).$$
小块插入排序开销为 $O(n\cdot TH)$，TH 为常数（如 32），仍为 $O(n)$，不改变主阶。故整体时间复杂度为 $O(n\log n)$。

## 渐进空间复杂度的分析，包含过程

除输入输出外，额外使用：一个长度为 $n$ 的辅助数组用于归并（$O(n)$）；找全局最小的临时数组在实现中也为 $O(n)$ 且可复用/释放；其余为常量级变量与少量计数器。按题目要求不计输入输出存储，算法额外空间主导项为
$$O(n).$$

## 遇到的困难和解决方法

1）三元比较器只返回最小和最大，难以直接进行普通二元比较：先求全局最小作为哨兵，用 compare(u,v,min) 间接判断大小。
2）如何减少 compare 次数以满足 limit：在归并时用 compare(x1,x2,y1) 一次推断三者相对关系，尽量一次输出两个元素；小段用插入排序减少归并层数与常数开销。
3）边界情况（某段不足两个元素）处理复杂：对称处理右段，最终剩 1 对 1 时退化为哨兵二元比较保证正确性。

## 估计完成本题所用时间

5 小时

## 关于本题的更多感想

这题本质是“受限比较模型”的算法工程：正确性来自哨兵把三元比较降维成二元比较，而性能来自在归并阶段“批量判定”的技巧。相比普通排序，更需要关注常数与比较次数的上界；调试时记录 compare 调用计数非常关键，能快速定位是否会超限。
