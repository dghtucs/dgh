## 算法思路和实现要点

把当前乐段看作序列 $a[1..L]$。一次测试给出若干前缀长度 $d_i$，每首曲子为 $a[1..d_i]$。序列 $b$ 能作为某曲子的“前奏和尾声”当且仅当 $b$ 同时是其前缀与后缀，且能写成 $b\cdot x\cdot b$，即满足 
$$2|b|\le d_i.$$
用 KMP 前缀函数 $\pi$：前缀 $d$ 的所有 border 长度为 $d,\pi[d],\pi[\pi[d]],\dots$。建立失配树（父亲为 $\pi$），则一个前缀的所有 border 正好是该节点的祖先集合。多个前缀的共同 border 等价于这些节点在失配树上的公共祖先，最大的共同 border 长度为它们的 LCA。再加上长度约束 $$|b|\le \left\lfloor \min(d_i)/2\right\rfloor,$$ 将 LCA 沿父指针向上跳到不超过该上界的最大祖先。为支持动态追加，KMP 可在线扩展，同时维护倍增祖先表用于 LCA 与跳祖先。

## 渐进时间复杂度的分析，包含过程

设最终总长度为 $L$（初始 $n$ 加上所有创作追加音符数），且 $\sum q_i\le 10^6$。
1）每次追加一个音符，按 KMP 递推计算 $\pi[L]$，总回退次数均摊为 $O(1)$，整体建表为 $$O(L).$$ 同时填倍增祖先表需 $O(\log L)$，故追加总计 $$O(L\log L).$$
2）一次测试包含 $q$ 个前缀长度：逐个做 LCA 合并，每次 LCA 用倍增提升，复杂度 $$O(\log L).$$ 再做一次“向上跳到 $\le limit$ 的祖先”同样 $$O(\log L).$$ 因此该测试为 $$O(q\log L).$$
总复杂度：
$$O(L\log L+\left(\sum_{\text{queries}} q\right)\log L).$$

## 渐进空间复杂度的分析，包含过程

额外存储包括：序列值 `val[1..L]`、前缀函数 `pi[1..L]`、深度 `dep[1..L]`，均为 $O(L)$；倍增祖先表 `up[j][i]` 共 $\lceil\log_2 L\rceil$ 层，因此为 $$O(L\log L).$$
整体渐进空间复杂度为
$$O(L\log L).$$

## 遇到的困难和解决方法

1）如何将“共同前奏和尾声”转化为可计算结构：利用 KMP 的 border 链，并将其视为失配树祖先集合，问题变为求 LCA。
2）还需满足 $2|b|\le d_i$ 的额外约束：先取所有前缀的 LCA，再用上界 $limit=\lfloor\min(d_i)/2\rfloor$，通过倍增跳祖先找到不超过上界的最大祖先

## 估计完成本题所用时间

5 小时

