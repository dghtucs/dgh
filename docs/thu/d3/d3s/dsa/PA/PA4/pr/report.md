## 算法思路和实现要点

采用二维滚动哈希：先对 $T$ 的每一行做长度为 $n$ 的子串哈希，得到 $rowHash[i][j]$（第 $i$ 行从列 $j$ 开始的长度 $n$ 哈希）。再固定列起点 $j$，把 $rowHash[0..M-1][j]$ 视为一维序列做竖向滚动哈希，得到每个 $m\times n$ 子矩阵的二维哈希。把所有子矩阵哈希插入自写开放寻址哈希表统计频次。对每个 $P_i$，计算其行哈希并按同样竖向合并得到二维哈希，在表中查询输出。为降低冲突，使用两套 64 位溢出哈希并将键设为 $(h_1,h_2)$。

## 渐进时间复杂度的分析，包含过程

设 $W=N-n+1,\ H=M-m+1$
1）计算 $T$ 每行前缀哈希并求所有长度 $n$ 子串哈希：每行 $O(N)$，共 $O(MN)$。
2）对每个列起点 $j\in[0,W-1]$：构建竖向前缀 $vpref$ 需 $O(M)$，再枚举顶部起点 $i\in[0,H-1]$ 取区间哈希并插入，需 $O(H)$，合计每列 $O(M+H)=O(M)$，总计 $O(WM)=O(M(N-n+1))\le O(MN)$。
3）每个模式计算哈希：$m$ 行每行 $n$ 字符，$O(mn)$，共 $O(kmn)$。
总时间复杂度：
$$O(MN + k mn).$$

## 渐进空间复杂度的分析，包含过程


1）存行子串哈希数组 $rowHash$（双哈希）：大小 $M\cdot W$，空间 $O(MW)$。
2）竖向前缀数组 $vpref$：长度 $M$，空间 $O(M)$。
3）自写哈希表存所有子矩阵哈希与计数：表容量与子矩阵数 $H\cdot W$ 同阶，空间 $O(HW)$。
其余为幂数组 $O(M+N)$。综合主导项为 $O(MW+HW)=O(MW)$，最坏 $W\approx N$，因此渐进空间复杂度：
$$O(MN).$$

## 遇到的困难和解决方法

1）二维匹配若逐格比较会超时：改用二维滚动哈希，把匹配化为哈希等值查询。
2）边界 $n>N$ 或 $m>M$：提前判断 $W,H$，仍读完输入但查询输出统一为 0。

## 估计完成本题所用时间

4 小时


