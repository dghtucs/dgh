

# Q1


### 1）该函数栈帧总大小（字节）

* 保存 `RA`：4
* 保存旧 `FP`：4
* `a[100]`：(100\times 4=400)
* `s`：4
* 动态数组 `b[N]`：(N\times 4=4N)

所以栈帧总大小：
$$
(4+4+400+4)+4N ;=; 412+4N
$$

---

### 2）补全函数序言（prologue）中的偏移量

先一次性给 **RA、旧FP、a、s** 分配固定大小空间：(412) 字节，再按 (4N) 给 `b` 分配。

```asm
func_prologue:
addi sp, sp, -412        # SP <- SP - 412
sw   ra, 408(sp)         # Mem[SP + 408] <- RA
sw   fp, 404(sp)         # Mem[SP + 404] <- FP
mv   fp, sp              # FP <- SP
lw   a0, 0x4000(zero)    # A0 <- Mem[0x4000] (= N)
slli a0, a0, 2           # A0 <- A0 * 4
sub  sp, sp, a0          # SP <- SP - 4N   (分配 b)
```

---

### 3）补全 `a[10] = b[5];` 对应代码中的偏移量

已知 `b[0]` 在当前 `sp` 指向处，所以：
$$
b[5]\text{ 的偏移} = 5\times 4 = 20
$$

而 `fp` 指向分配 `b` 之前的栈顶，也就是 **`s` 的起始地址**；`a` 紧接在 `s` 之上，所以：

* `s` 在 `0(fp)`
* `a[0]` 在 `4(fp)`
* `a[10]` 在 (4 + 10\times 4 = 44)

```asm
lw a0, 20(sp)     # A0 <- Mem[SP + 20]   (= b[5])
sw a0, 44(fp)     # Mem[FP + 44] <- A0   (= a[10])
```

---

### 4）溢出覆盖阈值（用 (N) 表示）

循环写入 `b[i]`（每次 4 字节），当 (i\ge N) 开始越界，按地址从低到高依次覆盖：`s`、`a`、旧FP、RA。

**(a) 覆盖返回值（即变量 s）**

第一次覆盖 `s` 发生在写 `b[N]` 时，需要循环执行到 (i=N)，即：
$$
L \ge N+1
$$

**(b) 覆盖返回地址 RA**

`RA` 位于 `fp+408`，而
$$
b[i]\text{ 地址}=sp+4i=(fp-4N)+4i
$$
令其等于 `fp+408`：
$$
(fp-4N)+4i = fp+408 ;\Rightarrow; 4(i-N)=408 ;\Rightarrow; i=N+102
$$
要真正写到这一项，需要 (L-1\ge N+102)，即：
$$
L \ge N+103
$$



# Q2



## 1）补全运行栈缺失部分（foo() 第二次被调用时）

按题图每个活动记录布局均为：`SL, DL, RA, 局部变量...`，且栈从**低编号到高编号增长**。

已知 `bar` 内调用 `baz()`，再由该 `baz()` 调用 `foo()`（第二次），因此缺失的两段分别是 **baz(第二次)** 与 **foo(第二次)** 的活动记录：

* **baz（第二次调用）** 的基址在 18：

  * 18：`0 (SL)`（baz 为全局函数，静态外层是全局）
  * 19：`13 (DL)`（动态调用者是 bar，bar 的活动记录基址为 13）
  * 20：`RA`
  * 21：`baz.x`

* **foo（第二次调用）** 的基址在 22：

  * 22：`0 (SL)`（foo 为全局函数，静态外层是全局）
  * 23：`18 (DL)`（动态调用者是 baz(第二次)，其基址为 18）
  * 24：`RA`（题图已给）
  * 25：`x`（题图已给）

---

## 2）用 Display 表代替静态链（SL 位置存“旧的 Display 表项”）

设词法层次：

* 全局作用域为 0 层
* `foo`、`baz` 为 1 层（在全局声明）
* `bar` 为 2 层（在 foo 内声明）

### 当前时刻 Display 表内容

当前调用链为：全局 → baz₁ → foo₁ → bar₁ → baz₂ → **foo₂(当前)**
因此最新的各层活动记录基址为：
$$
D_0=0,\quad D_1=22,\quad D_2=13
$$

### 各活动记录中“SL 位置”改存的内容（保存进入时旧的 (D_{\text{level}})）

进入某层过程时：把旧 (D_k) 存到该过程活动记录的 SL 位置，然后令 (D_k=) 当前活动记录基址。

于是图中所有 SL 位置的新内容应为（按活动记录出现顺序）：

* 全局记录（0 处 SL）：保存旧 (D_0)
  $$
  \text{pos }0:;0
  $$

* baz₁（5 处 SL，层 1）：进入前 (D_1=0)
  $$
  \text{pos }5:;0
  $$

* foo₁（9 处 SL，层 1）：进入前 (D_1=5)
  $$
  \text{pos }9:;5
  $$

* bar₁（13 处 SL，层 2）：进入前 (D_2=0)
  $$
  \text{pos }13:;0
  $$

* baz₂（18 处 SL，层 1）：进入前 (D_1=9)
  $$
  \text{pos }18:;9
  $$

* foo₂（22 处 SL，层 1）：进入前 (D_1=18)
  $$
  \text{pos }22:;18
  $$

（DL、RA、局部变量位置不变；仅把原来的“静态链 SL”槽位改为“保存旧 Display 项”。）

---

## 3）若改为动态作用域规则，第一次控制流不同发生在哪里？

在 **bar₁** 中执行：

```c
a = 3;
if (a > b) baz();
```

调用到 **baz₂** 后，baz 内有：

```c
if (a < b) foo();
```

* **静态作用域**：baz 中的 `a` 指向全局 `a`（仍为 1），`b` 为全局 2
  $$1<2\ \Rightarrow\ \text{调用 }foo()\ (\text{出现第二次 }foo)$$

* **动态作用域**：baz 中的 `a` 沿动态链最近绑定到 bar 的局部 `a=3`，`b` 仍是全局 2
  $$3<2\ \text{为假}\ \Rightarrow\ \text{不调用 }foo()$$

所以**第一次控制流不同**发生在 **baz() 里的**：

```c
if (a < b) foo();
```

这一判断处：动态作用域下不会进入第二次 `foo()` 调用。













# Q3






















# Q4














# Q5


















# Q6



