1. 不能提高流水线处理器 IPC 的是：**B. 提高时钟频率**

   * IPC 是“每个时钟周期完成的指令数”，提高频率只缩短周期，不改变每周期完成的指令条数。

2. “分支目标缓冲”（BTB）指的是：**B. 存储分支指令的跳转目标**

   * BTB 里保存的是分支指令的目标地址，用于快速给出预测的下一条取指地址。





下面按 4 问依次解答。

---

### 1）代码功能

初始化 `a0=0, a1=1`，循环 19 次做

* `a2=a0+a1`
* `a0=a1`
* `a1=a2`

这是斐波那契数列迭代。循环结束后 `a1=F20=6765`（以 F0=0,F1=1 定义），再把结果写到内存地址 `256` 处。

---

### 2）无分支预测时运行时间

**动态指令条数：**

* 入口 3 条：`addi a0`、`addi a1`、`addi t1`
* 循环体每次 5 条：`add` + 3 个 `addi` + `bne`
* 循环 19 次 → `19×5=95` 条
* 出口 3 条：`addi a0`、`addi t2`、`sw`

总指令数
[
N = 3 + 95 + 3 = 101
]

**流水线基础周期（无停顿）：**
5 级流水线完成 N 条需 (N+4) 周期
[
101 + 4 = 105
]

**分支停顿：**
题意：遇到分支 IF 一直 stall 到 EX 得到跳转地址，等价于 **每条分支 2 个周期罚时**。
循环中 `bne` 执行 19 次
[
19 \times 2 = 38
]

**总周期：**
[
105 + 38 = 143\text{ cycles}
]

主频 50 MHz → 周期 20 ns
[
143 \times 20\text{ ns} = 2860\text{ ns} \approx 2.86\ \mu s
]

---

### 3）加分支预测后时间减少多少

`bne` 的实际走向：前 18 次 **跳转**，最后 1 次 **不跳转**。
两位饱和计数器初值 00（强不跳），预测序列会产生：

* 第 1 次：预测不跳，实际跳 → 错
* 第 2 次：预测不跳，实际跳 → 错（状态到 10）
* 中间 16 次：预测跳，实际跳 → 对
* 最后 1 次：预测跳，实际不跳 → 错

**误预测 3 次。**

预测命中时不再 stall；误预测在 EX 才发现并改 PC，仍需冲刷 IF/ID，**每次误预测代价 2 周期**。

**新总周期：**
[
105 + 3\times 2 = 111\text{ cycles}
]

**节省周期与时间：**
[
143-111 = 32\text{ cycles}
]
[
32 \times 20\text{ ns} = 640\text{ ns} = 0.64\ \mu s
]

约减少
[
32/143 \approx 22.4%
]

---

### 4）多次调用同一函数返回错误原因（≤50字）

BTB 对 `jalr` 返回地址只记第一次目标且不更新，后续 `ra` 变了仍预测旧地址，导致返回错。




























下面给出第 4 题完整解答（按小问顺序）。

---

## 1）单周期 CPU：PUSH/POPRET 控制信号表

先根据题意确定两条新指令的行为：

* **PUSH**：
  计算新栈指针 `sp' = rs1 + PushOff`（PushOff 为常量偏移）；
  `rd ← sp'`；
  `Mem[sp'] ← rs2`（写存）。

* **POPRET**：
  计算 `addr = rs1 + imm`；
  `ra ← Mem[addr]`，并 **PC 跳转到 ra**；
  `rd ← addr`（更新栈指针）。

结合给的 datapath：

* BSel 为 3 选 1：0=imm，1=DataB(rs2)，2=PushOff（ADD 行已知 BSel=1 → DataB）。
* WBSel：1=ALU 结果（ADD 行已知）。
* MemRW：1 写存，0 读存。
* PCSel：0=PC+4；1=来自 EX(分支跳转目标)；2=来自 MEM（POPRET 读出的 ra）。

PushOff 典型为 **栈向低地址增长** → `PushOff = -4 = 0xFC`。

> 表中 “/” 表示无关。

| 指令         | PCSel | ImmSel | RFWEn | BSel  | ASel | ALUSel | PushOff  | MemRW | WBSel |
| ---------- | ----- | ------ | ----- | ----- | ---- | ------ | -------- | ----- | ----- |
| ADD        | 0     | /      | 1     | 1     | 0    | ADD    | /        | 0     | 1     |
| **PUSH**   | 0     | R      | 1     | **2** | 0    | ADD    | **0xFC** | **1** | 1     |
| **POPRET** | **2** | I      | 1     | **0** | 0    | ADD    | /        | 0     | 1     |

---

## 2a）流水线：当前周期 PC Mux 与 stall/bubble 控制

原则：

1. **不能同时 stall 和 bubble**。
2. 尽量少 stall。
3. 若有跳转，**优先选择更老（后级）的跳转源**。
4. 若访存未完成，则相关级及其之前级必须 stall。

### 情况 1

流水线：
IF=A(访存完成)  ID=B  EX=beq(跳转)  MEM=POPRET(访存完成)  WB=E

* 同周期既有 EX 分支跳转，又有 MEM 的 POPRET 跳转。
* **POPRET 更老，优先** → PC 取 MEM 给出的 ra。
* 需要清空所有更年轻的指令：IF/ID、ID/EX、EX/MEM bubble

| 序号 | PC Mux | PC | IF/ID      | ID/EX      | EX/MEM     | MEM/WB |
| -- | ------ | -- | ---------- | ---------- | ---------- | ------ |
| 1  | **2**  | 0  | **bubble** | **bubble** | **bubble** | 0      |

---

### 情况 2

流水线：
IF=A(访存完成)  ID=B  EX=POPRET  MEM=beq(跳转)  WB=E

* beq 的跳转在它 **EX 阶段上周期已经处理过**，此周期 MEM 不再改 PC。
* POPRET 在 EX 阶段，本周期还没读到 ra，**不能跳**。
* 无 stall / bubble，顺序取指

| 序号 | PC Mux | PC | IF/ID | ID/EX | EX/MEM | MEM/WB |
| -- | ------ | -- | ----- | ----- | ------ | ------ |
| 2  | **0**  | 0  | 0     | 0     | 0      | 0      |

---

### 情况 3

流水线：
IF=A(访存未完成)  ID=B  EX=beq(跳转)  MEM=POPRET(访存未完成)  WB=E

* IF 未完成 → PC 与 IF/ID 必须 stall。
* MEM 未完成 → EX/MEM 以及其之前级都必须 stall，保证 POPRET 留在 MEM。
* 因为整体 stall，本周期不做跳转清空。

| 序号 | PC Mux | PC        | IF/ID     | ID/EX     | EX/MEM    | MEM/WB    |
| -- | ------ | --------- | --------- | --------- | --------- | --------- |
| 3  | 0      | **stall** | **stall** | **stall** | **stall** | **stall** |

---

## 2b）PUSH 是否引入 load-use 冲突？

**结论：不会引入新的 load-use 类型冲突。**

逐个寄存器看：

* **rd（写回的新 sp）**：
  rd 的值由 ALU 在 EX 产生，下一条指令若使用 rd，可从 EX/MEM 或 MEM/WB 前传得到，**不需要停顿**。

* **rs1（旧 sp）**：
  rs1 只是普通 ALU 源操作数。若 rs1 依赖前一条 load，则这是**任何 ALU 指令都会遇到的经典 load-use**，不是 PUSH 特有；且题设有全前传，按原规则处理即可。

* **rs2（待压栈数据）**：
  rs2 作为 store data 在 MEM 阶段才需要。
  若前一条是 load 产出 rs2，则 load 在 MEM/WB 时数据已可前传到 PUSH 的 MEM 阶段，**可以无停顿完成**（题设“所有可能的数据前传”覆盖 store-data 前传）。

因此 PUSH 不会额外制造类似 load-use 的冲突。
