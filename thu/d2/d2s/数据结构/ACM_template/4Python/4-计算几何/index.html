<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../../../../../img/favicon.ico">
        <title>计算几何 - 勿怯 勿惰 勿贪 勿我</title>
        <link href="../../../../../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../../../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../../../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../../../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../../../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../../../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../../../../../..">勿怯 勿惰 勿贪 勿我</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../../../../../../.." class="nav-link">个人首页</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../../../../../../about/" class="nav-link">工具链接网址</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">清华</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../thu/" class="dropdown-item">清华</a>
</li>
                                    
<li>
    <a href="../../../../../../d1/d1/" class="dropdown-item">大一</a>
</li>
                                    
<li>
    <a href="../../../../../d2/" class="dropdown-item">大二</a>
</li>
                                    
<li>
    <a href="../../../../../../d3/d3/" class="dropdown-item">大三</a>
</li>
                                    
<li>
    <a href="../../../../../../d4/d4/" class="dropdown-item">大四</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">数学</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../math/math/" class="dropdown-item">数学</a>
</li>
                                    
<li>
    <a href="../../../../../../../math/caculus/" class="dropdown-item">微积分</a>
</li>
                                    
<li>
    <a href="../../../../../../../math/linear/" class="dropdown-item">线性代数</a>
</li>
                                    
<li>
    <a href="../../../../../../../math/probability/" class="dropdown-item">概率论</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">计算机</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../cs/cs/" class="dropdown-item">计算机</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">编程语言</a>
    <ul class="dropdown-menu">
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">C语言</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c/" class="dropdown-item">C</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">C++语言</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/cpp/" class="dropdown-item">C++</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">数据结构</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dsa/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">操作系统</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/os/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">计算机组成原理</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/jz/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">计算机网络</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jw/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">金融量化</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../finance/finance/" class="dropdown-item">金融</a>
</li>
                                    
<li>
    <a href="../../../../../../../finance/crypto/crypto/" class="dropdown-item">币</a>
</li>
                                    
<li>
    <a href="../../../../../../../finance/stock/stock/" class="dropdown-item">股票</a>
</li>
                                    
<li>
    <a href="../../../../../../../finance/quant/quant/" class="dropdown-item">量化</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">艺体</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../art/art/" class="dropdown-item">文学</a>
</li>
                                    
<li>
    <a href="../../../../../../../art/English/english/" class="dropdown-item">英语</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">读书</a>
    <ul class="dropdown-menu">
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">计算机</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../books/cs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lan/" class="dropdown-item">编程语言</a>
</li>
    </ul>
  </li>
            
<li>
    <a href="../../../../../../../books/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/gr/" class="dropdown-item">个人成长</a>
</li>
            
<li>
    <a href="../../../../../../../books/navy/zashu/" class="dropdown-item">杂书</a>
</li>
    </ul>
  </li>
                                    
<li>
    <a href="../../../../../../../art/music/" class="dropdown-item">音乐</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">生活记录</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../me/dgh/" class="dropdown-item">我是谁</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">2024</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2024/2024/" class="dropdown-item">2024年</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">8月</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%886%E6%97%A5/" class="dropdown-item">2024年8月6日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%887%E6%97%A5/" class="dropdown-item">2024年8月7日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%888%E6%97%A5/" class="dropdown-item">2024年8月8日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%889%E6%97%A5/" class="dropdown-item">2024年8月9日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8810%E6%97%A5/" class="dropdown-item">2024年8月10日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8811%E6%97%A5/" class="dropdown-item">2024年8月11日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8812%E6%97%A5/" class="dropdown-item">2024年8月12日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8813%E6%97%A5/" class="dropdown-item">2024年8月13日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8814%E6%97%A5/" class="dropdown-item">2024年8月14日</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">11月</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2024/11/2024%E5%B9%B411%E6%9C%8828%E6%97%A5/" class="dropdown-item">2024年11月28日</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">2025</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2025/2025%E5%B9%B4/" class="dropdown-item">2025年</a>
</li>
            
<li>
    <a href="../../../../../../../me/2025/1%E6%9C%88/2025%E5%B9%B41%E6%9C%88/" class="dropdown-item">2025年1月</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#_1" class="nav-link">计算几何</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">二维几何：点与向量</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_7" class="nav-link">多边形</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_11" class="nav-link">圆</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_19" class="nav-link">三维计算几何</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="_1">计算几何</h1>
<h2 id="_2">二维几何：点与向量</h2>
<pre><code class="language-cpp">#define y1 yy1
#define nxt(i) ((i + 1) % s.size())
typedef double LD;
const LD PI = 3.14159265358979323846;
const LD eps = 1E-10;
int sgn(LD x) { return fabs(x) &lt; eps ? 0 : (x &gt; 0 ? 1 : -1); }
struct L;
struct P;
typedef P V;
struct P {
    LD x, y;
    explicit P(LD x = 0, LD y = 0): x(x), y(y) {}
    explicit P(const L&amp; l);
};
struct L {
    P s, t;
    L() {}
    L(P s, P t): s(s), t(t) {}
};

P operator + (const P&amp; a, const P&amp; b) { return P(a.x + b.x, a.y + b.y); }
P operator - (const P&amp; a, const P&amp; b) { return P(a.x - b.x, a.y - b.y); }
P operator * (const P&amp; a, LD k) { return P(a.x * k, a.y * k); }
P operator / (const P&amp; a, LD k) { return P(a.x / k, a.y / k); }
inline bool operator &lt; (const P&amp; a, const P&amp; b) {
    return sgn(a.x - b.x) &lt; 0 || (sgn(a.x - b.x) == 0 &amp;&amp; sgn(a.y - b.y) &lt; 0);
}
bool operator == (const P&amp; a, const P&amp; b) { return !sgn(a.x - b.x) &amp;&amp; !sgn(a.y - b.y); }
P::P(const L&amp; l) { *this = l.t - l.s; }
ostream &amp;operator &lt;&lt; (ostream &amp;os, const P &amp;p) {
    return (os &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;);
}
istream &amp;operator &gt;&gt; (istream &amp;is, P &amp;p) {
    return (is &gt;&gt; p.x &gt;&gt; p.y);
}

LD dist(const P&amp; p) { return sqrt(p.x * p.x + p.y * p.y); }
LD dot(const V&amp; a, const V&amp; b) { return a.x * b.x + a.y * b.y; }
LD det(const V&amp; a, const V&amp; b) { return a.x * b.y - a.y * b.x; }
LD cross(const P&amp; s, const P&amp; t, const P&amp; o = P()) { return det(s - o, t - o); }
// --------------------------------------------
</code></pre>
<h3 id="_3">象限</h3>
<pre><code class="language-cpp">// 象限
int quad(P p) {
    int x = sgn(p.x), y = sgn(p.y);
    if (x &gt; 0 &amp;&amp; y &gt;= 0) return 1;
    if (x &lt;= 0 &amp;&amp; y &gt; 0) return 2;
    if (x &lt; 0 &amp;&amp; y &lt;= 0) return 3;
    if (x &gt;= 0 &amp;&amp; y &lt; 0) return 4;
    assert(0);
}

// 仅适用于参照点在所有点一侧的情况
struct cmp_angle {
    P p;
    bool operator () (const P&amp; a, const P&amp; b) {
//        int qa = quad(a - p), qb = quad(b - p);
//        if (qa != qb) return qa &lt; qb;
        int d = sgn(cross(a, b, p));
        if (d) return d &gt; 0;
        return dist(a - p) &lt; dist(b - p);
    }
};
</code></pre>
<h3 id="_4">线</h3>
<pre><code class="language-cpp">// 是否平行
bool parallel(const L&amp; a, const L&amp; b) {
    return !sgn(det(P(a), P(b)));
}
// 直线是否相等
bool l_eq(const L&amp; a, const L&amp; b) {
    return parallel(a, b) &amp;&amp; parallel(L(a.s, b.t), L(b.s, a.t));
}
// 逆时针旋转 r 弧度
P rotation(const P&amp; p, const LD&amp; r) { return P(p.x * cos(r) - p.y * sin(r), p.x * sin(r) + p.y * cos(r)); }
P RotateCCW90(const P&amp; p) { return P(-p.y, p.x); }
P RotateCW90(const P&amp; p) { return P(p.y, -p.x); }
// 单位法向量
V normal(const V&amp; v) { return V(-v.y, v.x) / dist(v); }
</code></pre>
<h3 id="_5">点与线</h3>
<pre><code class="language-cpp">// 点在线段上  &lt;= 0包含端点 &lt; 0 则不包含
bool p_on_seg(const P&amp; p, const L&amp; seg) {
    P a = seg.s, b = seg.t;
    return !sgn(det(p - a, b - a)) &amp;&amp; sgn(dot(p - a, p - b)) &lt;= 0;
}
// 点到直线距离
LD dist_to_line(const P&amp; p, const L&amp; l) {
    return fabs(cross(l.s, l.t, p)) / dist(l);
}
// 点到线段距离
LD dist_to_seg(const P&amp; p, const L&amp; l) {
    if (l.s == l.t) return dist(p - l);
    V vs = p - l.s, vt = p - l.t;
    if (sgn(dot(l, vs)) &lt; 0) return dist(vs);
    else if (sgn(dot(l, vt)) &gt; 0) return dist(vt);
    else return dist_to_line(p, l);
}
</code></pre>
<h3 id="_6">线与线</h3>
<pre><code class="language-cpp">// 求直线交 需要事先保证有界
P l_intersection(const L&amp; a, const L&amp; b) {
    LD s1 = det(P(a), b.s - a.s), s2 = det(P(a), b.t - a.s);
    return (b.s * s2 - b.t * s1) / (s2 - s1);
}
// 向量夹角的弧度
LD angle(const V&amp; a, const V&amp; b) {
    LD r = asin(fabs(det(a, b)) / dist(a) / dist(b));
    if (sgn(dot(a, b)) &lt; 0) r = PI - r;
    return r;
}
// 线段和直线是否有交   1 = 规范，2 = 不规范
int s_l_cross(const L&amp; seg, const L&amp; line) {
    int d1 = sgn(cross(line.s, line.t, seg.s));
    int d2 = sgn(cross(line.s, line.t, seg.t));
    if ((d1 ^ d2) == -2) return 1; // proper
    if (d1 == 0 || d2 == 0) return 2;
    return 0;
}
// 线段的交   1 = 规范，2 = 不规范
int s_cross(const L&amp; a, const L&amp; b, P&amp; p) {
    int d1 = sgn(cross(a.t, b.s, a.s)), d2 = sgn(cross(a.t, b.t, a.s));
    int d3 = sgn(cross(b.t, a.s, b.s)), d4 = sgn(cross(b.t, a.t, b.s));
    if ((d1 ^ d2) == -2 &amp;&amp; (d3 ^ d4) == -2) { p = l_intersection(a, b); return 1; }
    if (!d1 &amp;&amp; p_on_seg(b.s, a)) { p = b.s; return 2; }
    if (!d2 &amp;&amp; p_on_seg(b.t, a)) { p = b.t; return 2; }
    if (!d3 &amp;&amp; p_on_seg(a.s, b)) { p = a.s; return 2; }
    if (!d4 &amp;&amp; p_on_seg(a.t, b)) { p = a.t; return 2; }
    return 0;
}
</code></pre>
<h2 id="_7">多边形</h2>
<h3 id="_8">面积、凸包</h3>
<pre><code class="language-cpp">typedef vector&lt;P&gt; S;

// 点是否在多边形中 0 = 在外部 1 = 在内部 -1 = 在边界上
int inside(const S&amp; s, const P&amp; p) {
    int cnt = 0;
    FOR (i, 0, s.size()) {
        P a = s[i], b = s[nxt(i)];
        if (p_on_seg(p, L(a, b))) return -1;
        if (sgn(a.y - b.y) &lt;= 0) swap(a, b);
        if (sgn(p.y - a.y) &gt; 0) continue;
        if (sgn(p.y - b.y) &lt;= 0) continue;
        cnt += sgn(cross(b, a, p)) &gt; 0;
    }
    return bool(cnt &amp; 1);
}
// 多边形面积，有向面积可能为负
LD polygon_area(const S&amp; s) {
    LD ret = 0;
    FOR (i, 1, (LL)s.size() - 1)
        ret += cross(s[i], s[i + 1], s[0]);
    return ret / 2;
}
// 构建凸包 点不可以重复 &lt; 0 边上可以有点， &lt;= 0 则不能
// 会改变输入点的顺序
const int MAX_N = 1000;
S convex_hull(S&amp; s) {
//    assert(s.size() &gt;= 3);
    sort(s.begin(), s.end());
    S ret(MAX_N * 2);
    int sz = 0;
    FOR (i, 0, s.size()) {
        while (sz &gt; 1 &amp;&amp; sgn(cross(ret[sz - 1], s[i], ret[sz - 2])) &lt; 0) --sz;
        ret[sz++] = s[i];
    }
    int k = sz;
    FORD (i, (LL)s.size() - 2, -1) {
        while (sz &gt; k &amp;&amp; sgn(cross(ret[sz - 1], s[i], ret[sz - 2])) &lt; 0) --sz;
        ret[sz++] = s[i];
    }
    ret.resize(sz - (s.size() &gt; 1));
    return ret;
}

P ComputeCentroid(const vector&lt;P&gt; &amp;p) {
    P c(0, 0);
    LD scale = 6.0 * polygon_area(p);
    for (unsigned i = 0; i &lt; p.size(); i++) {
        unsigned j = (i + 1) % p.size();
        c = c + (p[i] + p[j]) * (p[i].x * p[j].y - p[j].x * p[i].y);
    }
    return c / scale;
}
</code></pre>
<h3 id="_9">旋转卡壳</h3>
<pre><code class="language-cpp">LD rotatingCalipers(vector&lt;P&gt;&amp; qs) {
    int n = qs.size();
    if (n == 2)
        return dist(qs[0] - qs[1]);
    int i = 0, j = 0;
    FOR (k, 0, n) {
        if (!(qs[i] &lt; qs[k])) i = k;
        if (qs[j] &lt; qs[k]) j = k;
    }
    LD res = 0;
    int si = i, sj = j;
    while (i != sj || j != si) {
        res = max(res, dist(qs[i] - qs[j]));
        if (sgn(cross(qs[(i+1)%n] - qs[i], qs[(j+1)%n] - qs[j])) &lt; 0)
            i = (i + 1) % n;
        else j = (j + 1) % n;
    } 
    return res;
}

int main() {
    int n;
    while (cin &gt;&gt; n) {
        S v(n);
        FOR (i, 0, n) cin &gt;&gt; v[i].x &gt;&gt; v[i].y;
        convex_hull(v);
        printf(&quot;%.0f\n&quot;, rotatingCalipers(v));
    }
}
</code></pre>
<h3 id="_10">半平面交</h3>
<pre><code class="language-cpp">struct LV {
    P p, v; LD ang;
    LV() {}
    LV(P s, P t): p(s), v(t - s) { ang = atan2(v.y, v.x); }
};  // 另一种向量表示

bool operator &lt; (const LV &amp;a, const LV&amp; b) { return a.ang &lt; b.ang; }
bool on_left(const LV&amp; l, const P&amp; p) { return sgn(cross(l.v, p - l.p)) &gt;= 0; }
P l_intersection(const LV&amp; a, const LV&amp; b) {
    P u = a.p - b.p; LD t = cross(b.v, u) / cross(a.v, b.v);
    return a.p + a.v * t;
}

S half_plane_intersection(vector&lt;LV&gt;&amp; L) {
    int n = L.size(), fi, la;
    sort(L.begin(), L.end());
    vector&lt;P&gt; p(n); vector&lt;LV&gt; q(n);
    q[fi = la = 0] = L[0];
    FOR (i, 1, n) {
        while (fi &lt; la &amp;&amp; !on_left(L[i], p[la - 1])) la--;
        while (fi &lt; la &amp;&amp; !on_left(L[i], p[fi])) fi++;
        q[++la] = L[i];
        if (sgn(cross(q[la].v, q[la - 1].v)) == 0) {
            la--;
            if (on_left(q[la], L[i].p)) q[la] = L[i];
        }
        if (fi &lt; la) p[la - 1] = l_intersection(q[la - 1], q[la]);
    }
    while (fi &lt; la &amp;&amp; !on_left(q[fi], p[la - 1])) la--;
    if (la - fi &lt;= 1) return vector&lt;P&gt;();
    p[la] = l_intersection(q[la], q[fi]);
    return vector&lt;P&gt;(p.begin() + fi, p.begin() + la + 1);
}

S convex_intersection(const vector&lt;P&gt; &amp;v1, const vector&lt;P&gt; &amp;v2) {
    vector&lt;LV&gt; h; int n = v1.size(), m = v2.size();
    FOR (i, 0, n) h.push_back(LV(v1[i], v1[(i + 1) % n]));
    FOR (i, 0, m) h.push_back(LV(v2[i], v2[(i + 1) % m]));
    return half_plane_intersection(h);
}
</code></pre>
<h2 id="_11">圆</h2>
<pre><code class="language-cpp">struct C {
    P p; LD r;
    C(LD x = 0, LD y = 0, LD r = 0): p(x, y), r(r) {}
    C(P p, LD r): p(p), r(r) {}
};
</code></pre>
<h3 id="_12">三点求圆心</h3>
<pre><code class="language-cpp">P compute_circle_center(P a, P b, P c) {
    b = (a + b) / 2;
    c = (a + c) / 2;
    return l_intersection({b, b + RotateCW90(a - b)}, {c , c + RotateCW90(a - c)});
}
</code></pre>
<h3 id="_13">圆线交点、圆圆交点</h3>
<ul>
<li>圆和线的交点关于圆心是顺时针的</li>
</ul>
<pre><code class="language-cpp">vector&lt;P&gt; c_l_intersection(const L&amp; l, const C&amp; c) {
    vector&lt;P&gt; ret;
    P b(l), a = l.s - c.p;
    LD x = dot(b, b), y = dot(a, b), z = dot(a, a) - c.r * c.r;
    LD D = y * y - x * z;
    if (sgn(D) &lt; 0) return ret;
    ret.push_back(c.p + a + b * (-y + sqrt(D + eps)) / x);
    if (sgn(D) &gt; 0) ret.push_back(c.p + a + b * (-y - sqrt(D)) / x);
    return ret;
}

vector&lt;P&gt; c_c_intersection(C a, C b) {
    vector&lt;P&gt; ret;
    LD d = dist(a.p - b.p);
    if (sgn(d) == 0 || sgn(d - (a.r + b.r)) &gt; 0 || sgn(d + min(a.r, b.r) - max(a.r, b.r)) &lt; 0)
        return ret;
    LD x = (d * d - b.r * b.r + a.r * a.r) / (2 * d);
    LD y = sqrt(a.r * a.r - x * x);
    P v = (b.p - a.p) / d;
    ret.push_back(a.p + v * x + RotateCCW90(v) * y);
    if (sgn(y) &gt; 0) ret.push_back(a.p + v * x - RotateCCW90(v) * y);
    return ret;
}
</code></pre>
<h3 id="_14">圆圆位置关系</h3>
<pre><code class="language-cpp">// 1:内含 2:内切 3:相交 4:外切 5:相离
int c_c_relation(const C&amp; a, const C&amp; v) {
    LD d = dist(a.p - v.p);
    if (sgn(d - a.r - v.r) &gt; 0) return 5;
    if (sgn(d - a.r - v.r) == 0) return 4;
    LD l = fabs(a.r - v.r);
    if (sgn(d - l) &gt; 0) return 3;
    if (sgn(d - l) == 0) return 2;
    if (sgn(d - l) &lt; 0) return 1;
}
</code></pre>
<h3 id="_15">圆与多边形交</h3>
<ul>
<li>HDU 5130</li>
<li>注意顺时针逆时针（可能要取绝对值）</li>
</ul>
<pre><code class="language-cpp">LD sector_area(const P&amp; a, const P&amp; b, LD r) {
    LD th = atan2(a.y, a.x) - atan2(b.y, b.x);
    while (th &lt;= 0) th += 2 * PI;
    while (th &gt; 2 * PI) th -= 2 * PI;
    th = min(th, 2 * PI - th);
    return r * r * th / 2;
}

LD c_tri_area(P a, P b, P center, LD r) {
    a = a - center; b = b - center;
    int ina = sgn(dist(a) - r) &lt; 0, inb = sgn(dist(b) - r) &lt; 0;
    // dbg(a, b, ina, inb);
    if (ina &amp;&amp; inb) {
        return fabs(cross(a, b)) / 2;
    } else {
        auto p = c_l_intersection(L(a, b), C(0, 0, r));
        if (ina ^ inb) {
            auto cr = p_on_seg(p[0], L(a, b)) ? p[0] : p[1];
            if (ina) return sector_area(b, cr, r) + fabs(cross(a, cr)) / 2;
            else return sector_area(a, cr, r) + fabs(cross(b, cr)) / 2;
        } else {
            if ((int) p.size() == 2 &amp;&amp; p_on_seg(p[0], L(a, b))) {
                if (dist(p[0] - a) &gt; dist(p[1] - a)) swap(p[0], p[1]);
                return sector_area(a, p[0], r) + sector_area(p[1], b, r)
                    + fabs(cross(p[0], p[1])) / 2;
            } else return sector_area(a, b, r);
        }
    }
}

typedef vector&lt;P&gt; S;
LD c_poly_area(S poly, const C&amp; c) {
    LD ret = 0; int n = poly.size();
    FOR (i, 0, n) {
        int t = sgn(cross(poly[i] - c.p, poly[(i + 1) % n] - c.p));
        if (t) ret += t * c_tri_area(poly[i], poly[(i + 1) % n], c.p, c.r);
    }
    return ret;
}
</code></pre>
<h3 id="_16">圆的离散化、面积并</h3>
<p>SPOJ: CIRU, EOJ: 284</p>
<ul>
<li>版本 1：复杂度 $O(n^3 \log n)$。虽然常数小，但还是难以接受。</li>
<li>优点？想不出来。</li>
<li>原理上是用竖线进行切分，然后对每一个切片分别计算。</li>
<li>扫描线部分可以魔改，求各种东西。</li>
</ul>
<pre><code class="language-cpp">inline LD rt(LD x) { return sgn(x) == 0 ? 0 : sqrt(x); }
inline LD sq(LD x) { return x * x; }

// 圆弧
// 如果按照 x 离散化，圆弧是 &quot;横着的&quot;
// 记录圆弧的左端点、右端点、中点的坐标，和圆弧所在的圆
// 调用构造要保证 c.x - x.r &lt;= xl &lt; xr &lt;= c.y + x.r
// t = 1 下圆弧 t = -1 上圆弧
struct CV {
    LD yl, yr, ym; C o; int type;
    CV() {}
    CV(LD yl, LD yr, LD ym, C c, int t)
        : yl(yl), yr(yr), ym(ym), type(t), o(c) {}
};

// 辅助函数 求圆上纵坐标
pair&lt;LD, LD&gt; c_point_eval(const C&amp; c, LD x) {
    LD d = fabs(c.p.x - x), h = rt(sq(c.r) - sq(d));
    return {c.p.y - h, c.p.y + h};
}
// 构造上下圆弧
pair&lt;CV, CV&gt; pairwise_curves(const C&amp; c, LD xl, LD xr) {
    LD yl1, yl2, yr1, yr2, ym1, ym2;
    tie(yl1, yl2) = c_point_eval(c, xl);
    tie(ym1, ym2) = c_point_eval(c, (xl + xr) / 2);
    tie(yr1, yr2) = c_point_eval(c, xr);
    return {CV(yl1, yr1, ym1, c, 1), CV(yl2, yr2, ym2, c, -1)};
}

// 离散化之后同一切片内的圆弧应该是不相交的
bool operator &lt; (const CV&amp; a, const CV&amp; b) { return a.ym &lt; b.ym; }
// 计算圆弧和连接圆弧端点的线段构成的封闭图形的面积
LD cv_area(const CV&amp; v, LD xl, LD xr) {
    LD l = rt(sq(xr - xl) + sq(v.yr - v.yl));
    LD d = rt(sq(v.o.r) - sq(l / 2));
    LD ang = atan(l / d / 2);
    return ang * sq(v.o.r) - d * l / 2;
}

LD circle_union(const vector&lt;C&gt;&amp; cs) {
    int n = cs.size();
    vector&lt;LD&gt; xs;
    FOR (i, 0, n) {
        xs.push_back(cs[i].p.x - cs[i].r);
        xs.push_back(cs[i].p.x);
        xs.push_back(cs[i].p.x + cs[i].r);
        FOR (j, i + 1, n) {
            auto pts = c_c_intersection(cs[i], cs[j]);
            for (auto&amp; p: pts) xs.push_back(p.x);
        }
    }
    sort(xs.begin(), xs.end());
    xs.erase(unique(xs.begin(), xs.end(), [](LD x, LD y) { return sgn(x - y) == 0; }), xs.end());
    LD ans = 0;
    FOR (i, 0, (int) xs.size() - 1) {
        LD xl = xs[i], xr = xs[i + 1];
        vector&lt;CV&gt; intv;
        FOR (k, 0, n) {
            auto&amp; c = cs[k];
            if (sgn(c.p.x - c.r - xl) &lt;= 0 &amp;&amp; sgn(c.p.x + c.r - xr) &gt;= 0) {
                auto t = pairwise_curves(c, xl, xr);
                intv.push_back(t.first); intv.push_back(t.second);
            }
        }
        sort(intv.begin(), intv.end());

        vector&lt;LD&gt; areas(intv.size());
        FOR (i, 0, intv.size()) areas[i] = cv_area(intv[i], xl, xr);

        int cc = 0;
        FOR (i, 0, intv.size()) {
            if (cc &gt; 0) {
                ans += (intv[i].yl - intv[i - 1].yl + intv[i].yr - intv[i - 1].yr) * (xr - xl) / 2;
                ans += intv[i - 1].type * areas[i - 1];
                ans -= intv[i].type * areas[i];
            }
            cc += intv[i].type;
        }
    }
    return ans;
}
</code></pre>
<ul>
<li>版本 2：复杂度 $O(n^2 \log n)$。</li>
<li>原理是：认为所求部分是一个奇怪的多边形 + 若干弓形。然后对于每个圆分别求贡献的弓形，并累加多边形有向面积。</li>
<li>同样可以魔改扫描线的部分，用于求周长、至少覆盖 $k$ 次等等。</li>
<li>内含、内切、同一个圆的情况，通常需要特殊处理。</li>
<li>下面的代码是 $k$ 圆覆盖。</li>
</ul>
<pre><code class="language-cpp">inline LD angle(const P&amp; p) { return atan2(p.y, p.x); }

// 圆弧上的点
// p 是相对于圆心的坐标
// a 是在圆上的 atan2 [-PI, PI]
struct CP {
    P p; LD a; int t;
    CP() {}
    CP(P p, LD a, int t): p(p), a(a), t(t) {}
};
bool operator &lt; (const CP&amp; u, const CP&amp; v) { return u.a &lt; v.a; }
LD cv_area(LD r, const CP&amp; q1, const CP&amp; q2) {
    return (r * r * (q2.a - q1.a) - cross(q1.p, q2.p)) / 2;
}

LD ans[N];
void circle_union(const vector&lt;C&gt;&amp; cs) {
    int n = cs.size();
    FOR (i, 0, n) {
        // 有相同的圆的话只考虑第一次出现
        bool ok = true;
        FOR (j, 0, i)
            if (sgn(cs[i].r - cs[j].r) == 0 &amp;&amp; cs[i].p == cs[j].p) {
                ok = false;
                break;
            }
        if (!ok) continue;
        auto&amp; c = cs[i];
        vector&lt;CP&gt; ev;
        int belong_to = 0;
        P bound = c.p + P(-c.r, 0);
        ev.emplace_back(bound, -PI, 0);
        ev.emplace_back(bound, PI, 0);
        FOR (j, 0, n) {
            if (i == j) continue;
            if (c_c_relation(c, cs[j]) &lt;= 2) {
                if (sgn(cs[j].r - c.r) &gt;= 0) // 完全被另一个圆包含，等于说叠了一层
                    belong_to++;
                continue;
            }
            auto its = c_c_intersection(c, cs[j]);
            if (its.size() == 2) {
                P p = its[1] - c.p, q = its[0] - c.p;
                LD a = angle(p), b = angle(q);
                if (sgn(a - b) &gt; 0) {
                    ev.emplace_back(p, a, 1);
                    ev.emplace_back(bound, PI, -1);
                    ev.emplace_back(bound, -PI, 1);
                    ev.emplace_back(q, b, -1);
                } else {
                    ev.emplace_back(p, a, 1);
                    ev.emplace_back(q, b, -1);
                }
            }
        }
        sort(ev.begin(), ev.end());
        int cc = ev[0].t;
        FOR (j, 1, ev.size()) {
            int t = cc + belong_to;
            ans[t] += cross(ev[j - 1].p + c.p, ev[j].p + c.p) / 2;
            ans[t] += cv_area(c.r, ev[j - 1], ev[j]);
            cc += ev[j].t;
        }
    }
}
</code></pre>
<h3 id="_17">最小圆覆盖</h3>
<ul>
<li>随机增量。期望复杂度 $O(n)$。</li>
</ul>
<pre><code class="language-cpp">P compute_circle_center(P a, P b) { return (a + b) / 2; }
bool p_in_circle(const P&amp; p, const C&amp; c) {
    return sgn(dist(p - c.p) - c.r) &lt;= 0;
}
C min_circle_cover(const vector&lt;P&gt; &amp;in) {
    vector&lt;P&gt; a(in.begin(), in.end());
    dbg(a.size());
    random_shuffle(a.begin(), a.end());
    P c = a[0]; LD r = 0; int n = a.size();
    FOR (i, 1, n) if (!p_in_circle(a[i], {c, r})) {
        c = a[i]; r = 0;
        FOR (j, 0, i) if (!p_in_circle(a[j], {c, r})) {
            c = compute_circle_center(a[i], a[j]);
            r = dist(a[j] - c);
            FOR (k, 0, j) if (!p_in_circle(a[k], {c, r})) {
                c = compute_circle_center(a[i], a[j], a[k]);
                r = dist(a[k] - c);
            }
        }
    }
    return {c, r};
}
</code></pre>
<h3 id="_18">圆的反演</h3>
<pre><code class="language-cpp">C inv(C c, const P&amp; o) {
    LD d = dist(c.p - o);
    assert(sgn(d) != 0);
    LD a = 1 / (d - c.r);
    LD b = 1 / (d + c.r);
    c.r = (a - b) / 2 * R2;
    c.p = o + (c.p - o) * ((a + b) * R2 / 2 / d);
    return c;
}
</code></pre>
<h2 id="_19">三维计算几何</h2>
<pre><code class="language-cpp">struct P;
struct L;
typedef P V;

struct P {
    LD x, y, z;
    explicit P(LD x = 0, LD y = 0, LD z = 0): x(x), y(y), z(z) {}
    explicit P(const L&amp; l);
};

struct L {
    P s, t;
    L() {}
    L(P s, P t): s(s), t(t) {}
};

struct F {
    P a, b, c;
    F() {}
    F(P a, P b, P c): a(a), b(b), c(c) {}
};

P operator + (const P&amp; a, const P&amp; b) { return P(a.x + b.x, a.y + b.y, a.z + b.z); }
P operator - (const P&amp; a, const P&amp; b) { return P(a.x - b.x, a.y - b.y, a.z - b.z); }
P operator * (const P&amp; a, LD k) { return P(a.x * k, a.y * k, a.z * k); }
P operator / (const P&amp; a, LD k) { return P(a.x / k, a.y / k, a.z / k); }
inline int operator &lt; (const P&amp; a, const P&amp; b) {
    return sgn(a.x - b.x) &lt; 0 || (sgn(a.x - b.x) == 0 &amp;&amp; (sgn(a.y - b.y) &lt; 0 ||
                                  (sgn(a.y - b.y) == 0 &amp;&amp; sgn(a.z - b.z) &lt; 0)));
}
bool operator == (const P&amp; a, const P&amp; b) { return !sgn(a.x - b.x) &amp;&amp; !sgn(a.y - b.y) &amp;&amp; !sgn(a.z - b.z); }
P::P(const L&amp; l) { *this = l.t - l.s; }
ostream &amp;operator &lt;&lt; (ostream &amp;os, const P &amp;p) {
    return (os &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;,&quot; &lt;&lt; p.z &lt;&lt; &quot;)&quot;);
}
istream &amp;operator &gt;&gt; (istream &amp;is, P &amp;p) {
    return (is &gt;&gt; p.x &gt;&gt; p.y &gt;&gt; p.z);
}

// --------------------------------------------
LD dist2(const P&amp; p) { return p.x * p.x + p.y * p.y + p.z * p.z; }
LD dist(const P&amp; p) { return sqrt(dist2(p)); }
LD dot(const V&amp; a, const V&amp; b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
P cross(const P&amp; v, const P&amp; w) {
    return P(v.y * w.z - v.z * w.y, v.z * w.x - v.x * w.z, v.x * w.y - v.y * w.x);
}
LD mix(const V&amp; a, const V&amp; b, const V&amp; c) { return dot(a, cross(b, c)); }
</code></pre>
<h3 id="_20">旋转</h3>
<pre><code class="language-cpp">// 逆时针旋转 r 弧度
// axis = 0 绕 x 轴
// axis = 1 绕 y 轴
// axis = 2 绕 z 轴
P rotation(const P&amp; p, const LD&amp; r, int axis = 0) {
    if (axis == 0)
        return P(p.x, p.y * cos(r) - p.z * sin(r), p.y * sin(r) + p.z * cos(r));
    else if (axis == 1)
        return P(p.z * cos(r) - p.x * sin(r), p.y, p.z * sin(r) + p.x * cos(r));
    else if (axis == 2)
        return P(p.x * cos(r) - p.y * sin(r), p.x * sin(r) + p.y * cos(r), p.z);
}
// n 是单位向量 表示旋转轴
// 模板是顺时针的
P rotation(const P&amp; p, const LD&amp; r, const P&amp; n) {
    LD c = cos(r), s = sin(r), x = n.x, y = n.y, z = n.z;
    // dbg(c, s);
    return P((x * x * (1 - c) + c) * p.x + (x * y * (1 - c) + z * s) * p.y + (x * z * (1 - c) - y * s) * p.z,
             (x * y * (1 - c) - z * s) * p.x + (y * y * (1 - c) + c) * p.y + (y * z * (1 - c) + x * s) * p.z,
             (x * z * (1 - c) + y * s) * p.x + (y * z * (1 - c) - x * s) * p.y + (z * z * (1 - c) + c) * p.z);
}
</code></pre>
<h3 id="_21">线、面</h3>
<p>函数相互依赖，所以交织在一起了。</p>
<pre><code class="language-cpp">// 点在线段上  &lt;= 0包含端点 &lt; 0 则不包含
bool p_on_seg(const P&amp; p, const L&amp; seg) {
    P a = seg.s, b = seg.t;
    return !sgn(dist2(cross(p - a, b - a))) &amp;&amp; sgn(dot(p - a, p - b)) &lt;= 0;
}
// 点到直线距离
LD dist_to_line(const P&amp; p, const L&amp; l) {
    return dist(cross(l.s - p, l.t - p)) / dist(l);
}
// 点到线段距离
LD dist_to_seg(const P&amp; p, const L&amp; l) {
    if (l.s == l.t) return dist(p - l.s);
    V vs = p - l.s, vt = p - l.t;
    if (sgn(dot(l, vs)) &lt; 0) return dist(vs);
    else if (sgn(dot(l, vt)) &gt; 0) return dist(vt);
    else return dist_to_line(p, l);
}

P norm(const F&amp; f) { return cross(f.a - f.b, f.b - f.c); }
int p_on_plane(const F&amp; f, const P&amp; p) { return sgn(dot(norm(f), p - f.a)) == 0; }

// 判两点在线段异侧 点在线段上返回 0 不共面无意义
int opposite_side(const P&amp; u, const P&amp; v, const L&amp; l) {
    return sgn(dot(cross(P(l), u - l.s), cross(P(l), v - l.s))) &lt; 0;
}

bool parallel(const L&amp; a, const L&amp; b) { return !sgn(dist2(cross(P(a), P(b)))); }
// 线段相交
int s_intersect(const L&amp; u, const L&amp; v) {
    return p_on_plane(F(u.s, u.t, v.s), v.t) &amp;&amp; 
           opposite_side(u.s, u.t, v) &amp;&amp;
           opposite_side(v.s, v.t, u);
}
</code></pre>
<h3 id="_22">凸包</h3>
<p>增量法。先将所有的点打乱顺序，然后选择四个不共面的点组成一个四面体，如果找不到说明凸包不存在。然后遍历剩余的点，不断更新凸包。对遍历到的点做如下处理。</p>
<ol>
<li>如果点在凸包内，则不更新。</li>
<li>如果点在凸包外，那么找到所有原凸包上所有分隔了对于这个点可见面和不可见面的边，以这样的边的两个点和新的点创建新的面加入凸包中。</li>
</ol>
<pre><code class="language-cpp">
struct FT {
    int a, b, c;
    FT() { }
    FT(int a, int b, int c) : a(a), b(b), c(c) { }
};

bool p_on_line(const P&amp; p, const L&amp; l) {
    return !sgn(dist2(cross(p - l.s, P(l))));
}

vector&lt;F&gt; convex_hull(vector&lt;P&gt; &amp;p) {
    sort(p.begin(), p.end());
    p.erase(unique(p.begin(), p.end()), p.end());
    random_shuffle(p.begin(), p.end());
    vector&lt;FT&gt; face;
    FOR (i, 2, p.size()) {
        if (p_on_line(p[i], L(p[0], p[1]))) continue;
        swap(p[i], p[2]);
        FOR (j, i + 1, p.size())
            if (sgn(mix(p[1] - p[0], p[2] - p[1], p[j] - p[0]))) {
                swap(p[j], p[3]);
                face.emplace_back(0, 1, 2);
                face.emplace_back(0, 2, 1);
                goto found;
            }
    }
found:
    vector&lt;vector&lt;int&gt;&gt; mk(p.size(), vector&lt;int&gt;(p.size()));
    FOR (v, 3, p.size()) {
        vector&lt;FT&gt; tmp;
        FOR (i, 0, face.size()) {
            int a = face[i].a, b = face[i].b, c = face[i].c;
            if (sgn(mix(p[a] - p[v], p[b] - p[v], p[c] - p[v])) &lt; 0) {
                mk[a][b] = mk[b][a] = v;
                mk[b][c] = mk[c][b] = v;
                mk[c][a] = mk[a][c] = v;
            } else tmp.push_back(face[i]);
        }
        face = tmp;
        FOR (i, 0, tmp.size()) {
            int a = face[i].a, b = face[i].b, c = face[i].c;
            if (mk[a][b] == v) face.emplace_back(b, a, v);
            if (mk[b][c] == v) face.emplace_back(c, b, v);
            if (mk[c][a] == v) face.emplace_back(a, c, v);
        }
    }
    vector&lt;F&gt; out;
    FOR (i, 0, face.size())
        out.emplace_back(p[face[i].a], p[face[i].b], p[face[i].c]);
    return out;
}
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../../../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../../../../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../../../../../js/base.js"></script>
        <script src="../../../../../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
