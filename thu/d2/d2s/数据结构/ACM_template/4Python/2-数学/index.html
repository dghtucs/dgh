<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../../../../../img/favicon.ico">
        <title>数学 - 勿怯 勿惰 勿贪 勿我</title>
        <link href="../../../../../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../../../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../../../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../../../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../../../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../../../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../../../../../..">勿怯 勿惰 勿贪 勿我</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../../../../../../.." class="nav-link">个人首页</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../../../../../../about/" class="nav-link">工具链接网址</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">清华</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../thu/" class="dropdown-item">清华</a>
</li>
                                    
<li>
    <a href="../../../../../../d1/d1/" class="dropdown-item">大一</a>
</li>
                                    
<li>
    <a href="../../../../../d2/" class="dropdown-item">大二</a>
</li>
                                    
<li>
    <a href="../../../../../../d3/d3/" class="dropdown-item">大三</a>
</li>
                                    
<li>
    <a href="../../../../../../d4/d4/" class="dropdown-item">大四</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">数学</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../math/math/" class="dropdown-item">数学</a>
</li>
                                    
<li>
    <a href="../../../../../../../math/caculus/" class="dropdown-item">微积分</a>
</li>
                                    
<li>
    <a href="../../../../../../../math/linear/" class="dropdown-item">线性代数</a>
</li>
                                    
<li>
    <a href="../../../../../../../math/probability/" class="dropdown-item">概率论</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">计算机</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../cs/cs/" class="dropdown-item">计算机</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">编程语言</a>
    <ul class="dropdown-menu">
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">C语言</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c/" class="dropdown-item">C</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">C++语言</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/cpp/" class="dropdown-item">C++</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">数据结构</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dsa/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">操作系统</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/os/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">计算机组成原理</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/jz/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">计算机网络</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jw/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">金融量化</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../finance/finance/" class="dropdown-item">金融</a>
</li>
                                    
<li>
    <a href="../../../../../../../finance/crypto/crypto/" class="dropdown-item">币</a>
</li>
                                    
<li>
    <a href="../../../../../../../finance/stock/stock/" class="dropdown-item">股票</a>
</li>
                                    
<li>
    <a href="../../../../../../../finance/quant/quant/" class="dropdown-item">量化</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">艺体</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../art/art/" class="dropdown-item">文学</a>
</li>
                                    
<li>
    <a href="../../../../../../../art/English/english/" class="dropdown-item">英语</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">读书</a>
    <ul class="dropdown-menu">
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">计算机</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../books/cs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lan/" class="dropdown-item">编程语言</a>
</li>
    </ul>
  </li>
            
<li>
    <a href="../../../../../../../books/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/gr/" class="dropdown-item">个人成长</a>
</li>
            
<li>
    <a href="../../../../../../../books/navy/zashu/" class="dropdown-item">杂书</a>
</li>
    </ul>
  </li>
                                    
<li>
    <a href="../../../../../../../art/music/" class="dropdown-item">音乐</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">生活记录</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../me/dgh/" class="dropdown-item">我是谁</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">2024</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2024/2024/" class="dropdown-item">2024年</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">8月</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%886%E6%97%A5/" class="dropdown-item">2024年8月6日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%887%E6%97%A5/" class="dropdown-item">2024年8月7日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%888%E6%97%A5/" class="dropdown-item">2024年8月8日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%889%E6%97%A5/" class="dropdown-item">2024年8月9日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8810%E6%97%A5/" class="dropdown-item">2024年8月10日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8811%E6%97%A5/" class="dropdown-item">2024年8月11日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8812%E6%97%A5/" class="dropdown-item">2024年8月12日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8813%E6%97%A5/" class="dropdown-item">2024年8月13日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8814%E6%97%A5/" class="dropdown-item">2024年8月14日</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">11月</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2024/11/2024%E5%B9%B411%E6%9C%8828%E6%97%A5/" class="dropdown-item">2024年11月28日</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">2025</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2025/2025%E5%B9%B4/" class="dropdown-item">2025年</a>
</li>
            
<li>
    <a href="../../../../../../../me/2025/1%E6%9C%88/2025%E5%B9%B41%E6%9C%88/" class="dropdown-item">2025年1月</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#_1" class="nav-link">数学</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">矩阵运算</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_3" class="nav-link">筛</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_4" class="nav-link">亚线性筛</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_6" class="nav-link">素数测试</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pollard-rho" class="nav-link">Pollard-Rho</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#bm" class="nav-link">BM 线性递推</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_7" class="nav-link">扩展欧几里得</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_8" class="nav-link">类欧几里得</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_9" class="nav-link">逆元</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_10" class="nav-link">组合数</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_11" class="nav-link">斯特灵数</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#fft-ntt-fwt" class="nav-link">FFT &amp; NTT &amp; FWT</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#simpson" class="nav-link">simpson 自适应积分</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_14" class="nav-link">快速乘</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_15" class="nav-link">快速幂</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_16" class="nav-link">高斯消元</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_17" class="nav-link">质因数分解</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_18" class="nav-link">原根</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_19" class="nav-link">公式</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_29" class="nav-link">二次剩余</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_30" class="nav-link">中国剩余定理</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_31" class="nav-link">伯努利数和等幂求和</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_32" class="nav-link">单纯形</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_33" class="nav-link">离散对数</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_34" class="nav-link">数论分块</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_35" class="nav-link">博弈</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="_1">数学</h1>
<h2 id="_2">矩阵运算</h2>
<pre><code class="language-cpp">struct Mat {
    static const LL M = 2;
    LL v[M][M];
    Mat() { memset(v, 0, sizeof v); }
    void eye() { FOR (i, 0, M) v[i][i] = 1; }
    LL* operator [] (LL x) { return v[x]; }
    const LL* operator [] (LL x) const { return v[x]; }
    Mat operator * (const Mat&amp; B) {
        const Mat&amp; A = *this;
        Mat ret;
        FOR (k, 0, M)
            FOR (i, 0, M) if (A[i][k])
                FOR (j, 0, M)     
                    ret[i][j] = (ret[i][j] + A[i][k] * B[k][j]) % MOD;
        return ret;
    }
    Mat pow(LL n) const {
        Mat A = *this, ret; ret.eye();
        for (; n; n &gt;&gt;= 1, A = A * A)
            if (n &amp; 1) ret = ret * A;
        return ret;
    }
    Mat operator + (const Mat&amp; B) {
        const Mat&amp; A = *this;
        Mat ret;
        FOR (i, 0, M)
            FOR (j, 0, M)
                 ret[i][j] = (A[i][j] + B[i][j]) % MOD;
        return ret;
    }
    void prt() const {
        FOR (i, 0, M)
            FOR (j, 0, M)
                 printf(&quot;%lld%c&quot;, (*this)[i][j], j == M - 1 ? '\n' : ' ');
    }
};
</code></pre>
<h2 id="_3">筛</h2>
<ul>
<li>线性筛</li>
</ul>
<pre><code class="language-cpp">const LL p_max = 1E6 + 100;
LL pr[p_max], p_sz;
void get_prime() {
    static bool vis[p_max];
    FOR (i, 2, p_max) {
        if (!vis[i]) pr[p_sz++] = i;
        FOR (j, 0, p_sz) {
            if (pr[j] * i &gt;= p_max) break;
            vis[pr[j] * i] = 1;
            if (i % pr[j] == 0) break;
        }
    }
}
</code></pre>
<ul>
<li>线性筛+欧拉函数</li>
</ul>
<pre><code class="language-cpp">const LL p_max = 1E5 + 100;
LL phi[p_max];
void get_phi() {
    phi[1] = 1;
    static bool vis[p_max];
    static LL prime[p_max], p_sz, d;
    FOR (i, 2, p_max) {
        if (!vis[i]) {
            prime[p_sz++] = i;
            phi[i] = i - 1;
        }
        for (LL j = 0; j &lt; p_sz &amp;&amp; (d = i * prime[j]) &lt; p_max; ++j) {
            vis[d] = 1;
            if (i % prime[j] == 0) {
                phi[d] = phi[i] * prime[j];
                break;
            }
            else phi[d] = phi[i] * (prime[j] - 1);
        }
    }
}
</code></pre>
<ul>
<li>线性筛+莫比乌斯函数</li>
</ul>
<pre><code class="language-cpp">const LL p_max = 1E5 + 100;
LL mu[p_max];
void get_mu() {
    mu[1] = 1;
    static bool vis[p_max];
    static LL prime[p_max], p_sz, d;
    FOR (i, 2, p_max) {
        if (!vis[i]) {
            prime[p_sz++] = i;
            mu[i] = -1;
        }
        for (LL j = 0; j &lt; p_sz &amp;&amp; (d = i * prime[j]) &lt; p_max; ++j) {
            vis[d] = 1;
            if (i % prime[j] == 0) {
                mu[d] = 0;
                break;
            }
            else mu[d] = -mu[i];
        }
    }
}
</code></pre>
<h2 id="_4">亚线性筛</h2>
<h3 id="min_25">min_25</h3>
<pre><code class="language-cpp">namespace min25 {
    const int M = 1E6 + 100;
    LL B, N;

    // g(x)
    inline LL pg(LL x) { return 1; }
    inline LL ph(LL x) { return x % MOD; }
    // Sum[g(i),{x,2,x}]
    inline LL psg(LL x) { return x % MOD - 1; }
    inline LL psh(LL x) {
        static LL inv2 = (MOD + 1) / 2;
        x %= MOD;
        return x * (x + 1) % MOD * inv2 % MOD - 1;
    }
    // f(pp=p^k)
    inline LL fpk(LL p, LL e, LL pp) { return (pp - pp / p) % MOD; }
    // f(p) = fgh(g(p), h(p))
    inline LL fgh(LL g, LL h) { return h - g; }

    LL pr[M], pc, sg[M], sh[M];
    void get_prime(LL n) {
        static bool vis[M]; pc = 0;
        FOR (i, 2, n + 1) {
            if (!vis[i]) {
                pr[pc++] = i;
                sg[pc] = (sg[pc - 1] + pg(i)) % MOD;
                sh[pc] = (sh[pc - 1] + ph(i)) % MOD;
            }
            FOR (j, 0, pc) {
                if (pr[j] * i &gt; n) break;
                vis[pr[j] * i] = 1;
                if (i % pr[j] == 0) break;
            }
        }
    }

    LL w[M];
    LL id1[M], id2[M], h[M], g[M];
    inline LL id(LL x) { return x &lt;= B ? id1[x] : id2[N / x]; }

    LL go(LL x, LL k) {
        if (x &lt;= 1 || (k &gt;= 0 &amp;&amp; pr[k] &gt; x)) return 0;
        LL t = id(x);
        LL ans = fgh((g[t] - sg[k + 1]), (h[t] - sh[k + 1]));
        FOR (i, k + 1, pc) {
            LL p = pr[i];
            if (p * p &gt; x) break;
            ans -= fgh(pg(p), ph(p));
            for (LL pp = p, e = 1; pp &lt;= x; ++e, pp = pp * p)
                ans += fpk(p, e, pp) * (1 + go(x / pp, i)) % MOD;
        }
        return ans % MOD;
    }

    LL solve(LL _N) {
        N = _N;
        B = sqrt(N + 0.5);
        get_prime(B);
        int sz = 0;
        for (LL l = 1, v, r; l &lt;= N; l = r + 1) {
            v = N / l; r = N / v;
            w[sz] = v; g[sz] = psg(v); h[sz] = psh(v);
            if (v &lt;= B) id1[v] = sz; else id2[r] = sz;
            sz++;
        }
        FOR (k, 0, pc) {
            LL p = pr[k];
            FOR (i, 0, sz) {
                LL v = w[i]; if (p * p &gt; v) break;
                LL t = id(v / p);
                g[i] = (g[i] - (g[t] - sg[k]) * pg(p)) % MOD;
                h[i] = (h[i] - (h[t] - sh[k]) * ph(p)) % MOD;
            }
        }
        return (go(N, -1) % MOD + MOD + 1) % MOD;
    }
    pair&lt;LL, LL&gt; sump(LL l, LL r) {
        return {h[id(r)] - h[id(l - 1)],
                g[id(r)] - g[id(l - 1)]};
    }
}
</code></pre>
<h3 id="_5">杜教筛</h3>
<p>求 $S(n)=\sum_{i=1}^n f(i)$，其中 $f$ 是一个积性函数。</p>
<p>构造一个积性函数 $g$，那么由 $(f<em>g)(n)=\sum_{d|n}f(d)g(\frac{n}{d})$，得到 $f(n)=(f</em>g)(n)-\sum_{d|n,d&lt;n}f(d)g(\frac{n}{d})$。</p>
<p>\begin{eqnarray}
g(1)S(n)&amp;=&amp;\sum_{i=1}^n (f<em>g)(i)-\sum_{i= 1}^{n}\sum_{d|i,d&lt;i}f(d)g(\frac{n}{d}) \
&amp;\overset{t=\frac{i}{d}}{=}&amp; \sum_{i=1}^n (f</em>g)(i)-\sum_{t=2}^{n} g(t) S(\lfloor \frac{n}{t} \rfloor)
\end{eqnarray}</p>
<p>当然，要能够由此计算 $S(n)$，会对 $f,g$ 提出一些要求：</p>
<ul>
<li>$f*g$ 要能够快速求前缀和。</li>
<li>$g$  要能够快速求分段和（前缀和）。</li>
<li>对于正常的积性函数 $g(1)=1$，所以不会有什么问题。</li>
</ul>
<p>在预处理 $S(n)$ 前 $n^{\frac{2}{3}}$ 项的情况下复杂度是 $O(n^{\frac{2}{3}})$。</p>
<pre><code class="language-cpp">namespace dujiao {
    const int M = 5E6;
    LL f[M] = {0, 1};
    void init() {
        static bool vis[M];
        static LL pr[M], p_sz, d;
        FOR (i, 2, M) {
            if (!vis[i]) { pr[p_sz++] = i; f[i] = -1; }
            FOR (j, 0, p_sz) {
                if ((d = pr[j] * i) &gt;= M) break;
                vis[d] = 1;
                if (i % pr[j] == 0) {
                    f[d] = 0;
                    break;
                } else f[d] = -f[i];
            }
        }
        FOR (i, 2, M) f[i] += f[i - 1];
    }
    inline LL s_fg(LL n) { return 1; }
    inline LL s_g(LL n) { return n; }

    LL N, rd[M];
    bool vis[M];
    LL go(LL n) {
        if (n &lt; M) return f[n];
        LL id = N / n;
        if (vis[id]) return rd[id];
        vis[id] = true;
        LL&amp; ret = rd[id] = s_fg(n);
        for (LL l = 2, v, r; l &lt;= n; l = r + 1) {
            v = n / l; r = n / v;
            ret -= (s_g(r) - s_g(l - 1)) * go(v);
        }
        return ret;
    }
    LL solve(LL n) {
        N = n;
        memset(vis, 0, sizeof vis);
        return go(n);
    }
}
</code></pre>
<h2 id="_6">素数测试</h2>
<ul>
<li>前置： 快速乘、快速幂</li>
<li>int 范围内只需检查 2, 7, 61</li>
<li>long long 范围 2, 325, 9375, 28178, 450775, 9780504, 1795265022</li>
<li>3E15内 2, 2570940, 880937, 610386380, 4130785767</li>
<li>4E13内 2, 2570940, 211991001, 3749873356</li>
<li>http://miller-rabin.appspot.com/</li>
</ul>
<pre><code class="language-cpp">bool checkQ(LL a, LL n) {
    if (n == 2) return 1;
    if (n == 1 || !(n &amp; 1)) return 0;
    LL d = n - 1;
    while (!(d &amp; 1)) d &gt;&gt;= 1;
    LL t = bin(a, d, n);  // 不一定需要快速乘
    while (d != n - 1 &amp;&amp; t != 1 &amp;&amp; t != n - 1) {
        t = mul(t, t, n);
        d &lt;&lt;= 1;
    }
    return t == n - 1 || d &amp; 1;
}

bool primeQ(LL n) {
    static vector&lt;LL&gt; t = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
    if (n &lt;= 1) return false;
    for (LL k: t) if (!checkQ(k, n)) return false;
    return true;
}
</code></pre>
<h2 id="pollard-rho">Pollard-Rho</h2>
<pre><code class="language-cpp">mt19937 mt(time(0));
LL pollard_rho(LL n, LL c) {
    LL x = uniform_int_distribution&lt;LL&gt;(1, n - 1)(mt), y = x;
    auto f = [&amp;](LL v) { LL t = mul(v, v, n) + c; return t &lt; n ? t : t - n; };
    while (1) {
        x = f(x); y = f(f(y));
        if (x == y) return n;
        LL d = gcd(abs(x - y), n);
        if (d != 1) return d;
    }
}

LL fac[100], fcnt;
void get_fac(LL n, LL cc = 19260817) {
    if (n == 4) { fac[fcnt++] = 2; fac[fcnt++] = 2; return; }
    if (primeQ(n)) { fac[fcnt++] = n; return; }
    LL p = n;
    while (p == n) p = pollard_rho(n, --cc);
    get_fac(p); get_fac(n / p);
}

void go_fac(LL n) { fcnt = 0; if (n &gt; 1) get_fac(n); }
</code></pre>
<h2 id="bm">BM 线性递推</h2>
<pre><code class="language-cpp">namespace BerlekampMassey {
    using V = vector&lt;LL&gt;;
    inline void up(LL&amp; a, LL b) { (a += b) %= MOD; }
    V mul(const V&amp;a, const V&amp; b, const V&amp; m, int k) {
        V r; r.resize(2 * k - 1);
        FOR (i, 0, k) FOR (j, 0, k) up(r[i + j], a[i] * b[j]);
        FORD (i, k - 2, -1) {
            FOR (j, 0, k) up(r[i + j], r[i + k] * m[j]);
            r.pop_back();
        }
        return r;
    }

    V pow(LL n, const V&amp; m) {
        int k = (int) m.size() - 1; assert (m[k] == -1 || m[k] == MOD - 1);
        V r(k), x(k); r[0] = x[1] = 1;
        for (; n; n &gt;&gt;= 1, x = mul(x, x, m, k))
            if (n &amp; 1) r = mul(x, r, m, k);
        return r;
    }

    LL go(const V&amp; a, const V&amp; x, LL n) {
        // a: (-1, a1, a2, ..., ak).reverse
        // x: x1, x2, ..., xk
        // x[n] = sum[a[i]*x[n-i],{i,1,k}]
        int k = (int) a.size() - 1;
        if (n &lt;= k) return x[n - 1];
        if (a.size() == 2) return x[0] * bin(a[0], n - 1, MOD) % MOD;
        V r = pow(n - 1, a);
        LL ans = 0;
        FOR (i, 0, k) up(ans, r[i] * x[i]);
        return (ans + MOD) % MOD;
    }

    V BM(const V&amp; x) {
        V C{-1}, B{-1};
        LL L = 0, m = 1, b = 1;
        FOR (n, 0, x.size()) {
            LL d = 0;
            FOR (i, 0, L + 1) up(d, C[i] * x[n - i]);
            if (d == 0) { ++m; continue; }
            V T = C;
            LL c = MOD - d * get_inv(b, MOD) % MOD;
            FOR (_, C.size(), B.size() + m) C.push_back(0);
            FOR (i, 0, B.size()) up(C[i + m], c * B[i]);
            if (2 * L &gt; n) { ++m; continue; }
            L = n + 1 - L; B.swap(T); b = d; m = 1;
        }
        reverse(C.begin(), C.end());
        return C;
    }
}
</code></pre>
<h2 id="_7">扩展欧几里得</h2>
<ul>
<li>求 $ax+by=gcd(a,b)$ 的一组解</li>
<li>如果 $a$ 和 $b$ 互素，那么 $x$ 是 $a$ 在模 $b$ 下的逆元</li>
<li>注意 $x$ 和 $y$ 可能是负数</li>
</ul>
<pre><code class="language-cpp">LL ex_gcd(LL a, LL b, LL &amp;x, LL &amp;y) {
    if (b == 0) { x = 1; y = 0; return a; }
    LL ret = ex_gcd(b, a % b, y, x);
    y -= a / b * x;
    return ret;
}
</code></pre>
<ul>
<li>卡常欧几里得</li>
</ul>
<pre><code class="language-cpp">inline int ctz(LL x) { return __builtin_ctzll(x); }
LL gcd(LL a, LL b) {
    if (!a) return b; if (!b) return a;
    int t = ctz(a | b);
    a &gt;&gt;= ctz(a);
    do {
        b &gt;&gt;= ctz(b);
        if (a &gt; b) swap(a, b);
        b -= a;
    } while (b);
    return a &lt;&lt; t;
}
</code></pre>
<h2 id="_8">类欧几里得</h2>
<ul>
<li>$m = \lfloor \frac{an+b}{c} \rfloor$.</li>
<li>$f(a,b,c,n)=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor$: 当 $a \ge c$ or $b \ge c$ 时，$f(a,b,c,n)=(\frac{a}{c})n(n+1)/2+(\frac{b}{c})(n+1)+f(a \bmod c,b \bmod c,c,n)$；否则 $f(a,b,c,n)=nm-f(c,c-b-1,a,m-1)$。</li>
<li>$g(a,b,c,n)=\sum_{i=0}^n i \lfloor\frac{ai+b}{c}\rfloor$: 当 $a \ge c$ or $b \ge c$ 时，$g(a,b,c,n)=(\frac{a}{c})n(n+1)(2n+1)/6+(\frac{b}{c})n(n+1)/2+g(a \bmod c,b \bmod c,c,n)$；否则 $g(a,b,c,n)=\frac{1}{2} (n(n+1)m-f(c,c-b-1,a,m-1)-h(c,c-b-1,a,m-1))$。</li>
<li>$h(a,b,c,n)=\sum_{i=0}^n\lfloor \frac{ai+b}{c} \rfloor^2$: 当 $a \ge c$ or $b \ge c$ 时，$h(a,b,c,n)=(\frac{a}{c})^2 n(n+1)(2n+1)/6 +(\frac{b}{c})^2 (n+1)+(\frac{a}{c})(\frac{b}{c})n(n+1)+h(a \bmod c, b \bmod c,c,n)+2(\frac{a}{c})g(a \bmod c,b \bmod c,c,n)+2(\frac{b}{c})f(a \bmod c,b \bmod c,c,n)$；否则 $h(a,b,c,n)=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)$。</li>
</ul>
<h2 id="_9">逆元</h2>
<ul>
<li>
<p>如果 $p$ 不是素数，使用拓展欧几里得</p>
</li>
<li>
<p>前置模板：快速幂 / 扩展欧几里得</p>
</li>
</ul>
<pre><code class="language-cpp">inline LL get_inv(LL x, LL p) { return bin(x, p - 2, p); }
LL get_inv(LL a, LL M) {
    static LL x, y;
    assert(exgcd(a, M, x, y) == 1);
    return (x % M + M) % M;
}
</code></pre>
<ul>
<li>预处理 1~n 的逆元</li>
</ul>
<pre><code class="language-cpp">LL inv[N];
void inv_init(LL n, LL p) {
    inv[1] = 1;
    FOR (i, 2, n)
        inv[i] = (p - p / i) * inv[p % i] % p;
}
</code></pre>
<ul>
<li>预处理阶乘及其逆元</li>
</ul>
<pre><code class="language-cpp">LL invf[M], fac[M] = {1};
void fac_inv_init(LL n, LL p) {
    FOR (i, 1, n)
        fac[i] = i * fac[i - 1] % p;
    invf[n - 1] = bin(fac[n - 1], p - 2, p);
    FORD (i, n - 2, -1)
        invf[i] = invf[i + 1] * (i + 1) % p;
}
</code></pre>
<h2 id="_10">组合数</h2>
<ul>
<li>如果数较小，模较大时使用逆元</li>
<li>前置模板：逆元-预处理阶乘及其逆元</li>
</ul>
<pre><code class="language-cpp">inline LL C(LL n, LL m) { // n &gt;= m &gt;= 0
    return n &lt; m || m &lt; 0 ? 0 : fac[n] * invf[m] % MOD * invf[n - m] % MOD;
}
</code></pre>
<ul>
<li>如果模数较小，数字较大，使用 Lucas 定理</li>
<li>前置模板可选1：求组合数    （如果使用阶乘逆元，需<code>fac_inv_init(MOD, MOD);</code>）</li>
<li>前置模板可选2：模数不固定下使用，无法单独使用。</li>
</ul>
<pre><code class="language-cpp">LL C(LL n, LL m) { // m &gt;= n &gt;= 0
    if (m - n &lt; n) n = m - n;
    if (n &lt; 0) return 0;
    LL ret = 1;
    FOR (i, 1, n + 1)
        ret = ret * (m - n + i) % MOD * bin(i, MOD - 2, MOD) % MOD;
    return ret;
}
</code></pre>
<pre><code class="language-cpp">LL Lucas(LL n, LL m) { // m &gt;= n &gt;= 0
    return m ? C(n % MOD, m % MOD) * Lucas(n / MOD, m / MOD) % MOD : 1;
}
</code></pre>
<ul>
<li>组合数预处理</li>
</ul>
<pre><code class="language-cpp">LL C[M][M];
void init_C(int n) {
    FOR (i, 0, n) {
        C[i][0] = C[i][i] = 1;
        FOR (j, 1, i)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
    }
}
</code></pre>
<h2 id="_11">斯特灵数</h2>
<h3 id="_12">第一类斯特灵数</h3>
<ul>
<li>绝对值是 $n$ 个元素划分为 $k$ 个环排列的方案数。</li>
<li>$s(n,k)=s(n-1,k-1)+(n-1)s(n-1,k)$</li>
</ul>
<h3 id="_13">第二类斯特灵数</h3>
<ul>
<li>$n$  个元素划分为 $k$ 个等价类的方案数</li>
<li>$S(n, k)=S(n-1,k-1)+kS(n-1, k)$</li>
</ul>
<pre><code class="language-cpp">S[0][0] = 1;
FOR (i, 1, N)
    FOR (j, 1, i + 1) S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD;
</code></pre>
<h2 id="fft-ntt-fwt">FFT &amp; NTT &amp; FWT</h2>
<h3 id="ntt">NTT</h3>
<pre><code class="language-cpp">LL wn[N &lt;&lt; 2], rev[N &lt;&lt; 2];
int NTT_init(int n_) {
    int step = 0; int n = 1;
    for ( ; n &lt; n_; n &lt;&lt;= 1) ++step;
    FOR (i, 1, n)
        rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (step - 1));
    int g = bin(G, (MOD - 1) / n, MOD);
    wn[0] = 1;
    for (int i = 1; i &lt;= n; ++i)
        wn[i] = wn[i - 1] * g % MOD;
    return n;
}

void NTT(LL a[], int n, int f) {
    FOR (i, 0, n) if (i &lt; rev[i])
        std::swap(a[i], a[rev[i]]);
    for (int k = 1; k &lt; n; k &lt;&lt;= 1) {
        for (int i = 0; i &lt; n; i += (k &lt;&lt; 1)) {
            int t = n / (k &lt;&lt; 1);
            FOR (j, 0, k) {
                LL w = f == 1 ? wn[t * j] : wn[n - t * j];
                LL x = a[i + j];
                LL y = a[i + j + k] * w % MOD;
                a[i + j] = (x + y) % MOD;
                a[i + j + k] = (x - y + MOD) % MOD;
            }
        }
    }
    if (f == -1) {
        LL ninv = get_inv(n, MOD);
        FOR (i, 0, n)
            a[i] = a[i] * ninv % MOD;
    }
}
</code></pre>
<h3 id="fft">FFT</h3>
<ul>
<li>n 需补成 2 的幂 （n 必须超过 a 和 b 的最高指数之和）</li>
</ul>
<pre><code class="language-cpp">typedef double LD;
const LD PI = acos(-1);
struct C {
    LD r, i;
    C(LD r = 0, LD i = 0): r(r), i(i) {}
};
C operator + (const C&amp; a, const C&amp; b) {
    return C(a.r + b.r, a.i + b.i);
}
C operator - (const C&amp; a, const C&amp; b) {
    return C(a.r - b.r, a.i - b.i);
}
C operator * (const C&amp; a, const C&amp; b) {
    return C(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r);
}

void FFT(C x[], int n, int p) {
    for (int i = 0, t = 0; i &lt; n; ++i) {
        if (i &gt; t) swap(x[i], x[t]);
        for (int j = n &gt;&gt; 1; (t ^= j) &lt; j; j &gt;&gt;= 1);
    }
    for (int h = 2; h &lt;= n; h &lt;&lt;= 1) {
        C wn(cos(p * 2 * PI / h), sin(p * 2 * PI / h));
        for (int i = 0; i &lt; n; i += h) {
            C w(1, 0), u;
            for (int j = i, k = h &gt;&gt; 1; j &lt; i + k; ++j) {
                u = x[j + k] * w;
                x[j + k] = x[j] - u;
                x[j] = x[j] + u;
                w = w * wn;
            }
        }
    }
    if (p == -1)
        FOR (i, 0, n)
            x[i].r /= n;
}

void conv(C a[], C b[], int n) {
    FFT(a, n, 1);
    FFT(b, n, 1);
    FOR (i, 0, n)
        a[i] = a[i] * b[i];
    FFT(a, n, -1);
}
</code></pre>
<h3 id="fwt">FWT</h3>
<ul>
<li>$C_k=\sum_{i \oplus j=k} A_i B_j$</li>
<li>FWT 完后需要先模一遍</li>
</ul>
<pre><code class="language-cpp">template&lt;typename T&gt;
void fwt(LL a[], int n, T f) {
    for (int d = 1; d &lt; n; d *= 2)
        for (int i = 0, t = d * 2; i &lt; n; i += t)
            FOR (j, 0, d)
                f(a[i + j], a[i + j + d]);
}

void AND(LL&amp; a, LL&amp; b) { a += b; }
void OR(LL&amp; a, LL&amp; b) { b += a; }
void XOR (LL&amp; a, LL&amp; b) {
    LL x = a, y = b;
    a = (x + y) % MOD;
    b = (x - y + MOD) % MOD;
}
void rAND(LL&amp; a, LL&amp; b) { a -= b; }
void rOR(LL&amp; a, LL&amp; b) { b -= a; }
void rXOR(LL&amp; a, LL&amp; b) {
    static LL INV2 = (MOD + 1) / 2;
    LL x = a, y = b;
    a = (x + y) * INV2 % MOD;
    b = (x - y + MOD) * INV2 % MOD;
}
</code></pre>
<ul>
<li>FWT 子集卷积</li>
</ul>
<pre><code class="language-text">a[popcount(x)][x] = A[x]
b[popcount(x)][x] = B[x]
fwt(a[i]) fwt(b[i])
c[i + j][x] += a[i][x] * b[j][x]
rfwt(c[i])
ans[x] = c[popcount(x)][x]
</code></pre>
<h2 id="simpson">simpson 自适应积分</h2>
<pre><code class="language-cpp">LD simpson(LD l, LD r) {
    LD c = (l + r) / 2;
    return (f(l) + 4 * f(c) + f(r)) * (r - l) / 6;
}

LD asr(LD l, LD r, LD eps, LD S) {
    LD m = (l + r) / 2;
    LD L = simpson(l, m), R = simpson(m, r);
    if (fabs(L + R - S) &lt; 15 * eps) return L + R + (L + R - S) / 15;
    return asr(l, m, eps / 2, L) + asr(m, r, eps / 2, R);
}

LD asr(LD l, LD r, LD eps) { return asr(l, r, eps, simpson(l, r)); }
</code></pre>
<ul>
<li>FWT</li>
</ul>
<pre><code class="language-cpp">template&lt;typename T&gt;
void fwt(LL a[], int n, T f) {
    for (int d = 1; d &lt; n; d *= 2)
        for (int i = 0, t = d * 2; i &lt; n; i += t)
            FOR (j, 0, d)
                 f(a[i + j], a[i + j + d]);
}

auto f = [](LL&amp; a, LL&amp; b) { // xor
        LL x = a, y = b;
        a = (x + y) % MOD;
        b = (x - y + MOD) % MOD;
};
</code></pre>
<h2 id="_14">快速乘</h2>
<pre><code class="language-cpp">LL mul(LL a, LL b, LL m) {
    LL ret = 0;
    while (b) {
        if (b &amp; 1) {
            ret += a;
            if (ret &gt;= m) ret -= m;
        }
        a += a;
        if (a &gt;= m) a -= m;
        b &gt;&gt;= 1;
    }
    return ret;
}
</code></pre>
<ul>
<li>O(1)</li>
</ul>
<pre><code class="language-cpp">LL mul(LL u, LL v, LL p) {
    return (u * v - LL((long double) u * v / p) * p + p) % p;
}
LL mul(LL u, LL v, LL p) { // 卡常
    LL t = u * v - LL((long double) u * v / p) * p;
    return t &lt; 0 ? t + p : t;
}
</code></pre>
<h2 id="_15">快速幂</h2>
<ul>
<li>如果模数是素数，则可在函数体内加上<code>n %= MOD - 1;</code>（费马小定理）。</li>
</ul>
<pre><code class="language-cpp">LL bin(LL x, LL n, LL MOD) {
    LL ret = MOD != 1;
    for (x %= MOD; n; n &gt;&gt;= 1, x = x * x % MOD)
        if (n &amp; 1) ret = ret * x % MOD;
    return ret;
}
</code></pre>
<ul>
<li>防爆 LL</li>
<li>前置模板：快速乘</li>
</ul>
<pre><code class="language-cpp">LL bin(LL x, LL n, LL MOD) {
    LL ret = MOD != 1;
    for (x %= MOD; n; n &gt;&gt;= 1, x = mul(x, x, MOD))
        if (n &amp; 1) ret = mul(ret, x, MOD);
    return ret;
}
</code></pre>
<h2 id="_16">高斯消元</h2>
<ul>
<li>n - 方程个数，m - 变量个数， a 是 n * (m + 1) 的增广矩阵，free 是否为自由变量</li>
<li>
<p>返回自由变量个数，-1 无解</p>
</li>
<li>
<p>浮点数版本</p>
</li>
</ul>
<pre><code class="language-cpp">typedef double LD;
const LD eps = 1E-10;
const int maxn = 2000 + 10;

int n, m;
LD a[maxn][maxn], x[maxn];
bool free_x[maxn];

inline int sgn(LD x) { return (x &gt; eps) - (x &lt; -eps); }

int gauss(LD a[maxn][maxn], int n, int m) {
    memset(free_x, 1, sizeof free_x); memset(x, 0, sizeof x);
    int r = 0, c = 0;
    while (r &lt; n &amp;&amp; c &lt; m) {
        int m_r = r;
        FOR (i, r + 1, n)
            if (fabs(a[i][c]) &gt; fabs(a[m_r][c])) m_r = i;
        if (m_r != r)
            FOR (j, c, m + 1)
                 swap(a[r][j], a[m_r][j]);
        if (!sgn(a[r][c])) {
            a[r][c] = 0;
            ++c;
            continue;
        }
        FOR (i, r + 1, n)
            if (a[i][c]) {
                LD t = a[i][c] / a[r][c];
                FOR (j, c, m + 1) a[i][j] -= a[r][j] * t;
            }
        ++r; ++c;
    }
    FOR (i, r, n)
        if (sgn(a[i][m])) return -1;
    if (r &lt; m) {
        FORD (i, r - 1, -1) {
            int f_cnt = 0, k = -1;
            FOR (j, 0, m)
                if (sgn(a[i][j]) &amp;&amp; free_x[j]) {
                    ++f_cnt;
                    k = j;
                }
            if(f_cnt &gt; 0) continue;
            LD s = a[i][m];
            FOR (j, 0, m)
                if (j != k) s -= a[i][j] * x[j];
            x[k] = s / a[i][k];
            free_x[k] = 0;
        }
        return m - r;
    }
    FORD (i, m - 1, -1) {
        LD s = a[i][m];
        FOR (j, i + 1, m)
            s -= a[i][j] * x[j];
        x[i] = s / a[i][i];
    }
    return 0;
}
</code></pre>
<ul>
<li>数据</li>
</ul>
<pre><code>3 4
1 1 -2 2
2 -3 5 1
4 -1 1 5
5 0 -1 7
// many

3 4
1 1 -2 2
2 -3 5 1
4 -1 -1 5
5 0 -1 0 2
// no

3 4
1 1 -2 2
2 -3 5 1
4 -1 1 5
5 0 1 0 7
// one
</code></pre>
<h2 id="_17">质因数分解</h2>
<ul>
<li>
<p>前置模板：素数筛</p>
</li>
<li>
<p>带指数</p>
</li>
</ul>
<pre><code class="language-cpp">LL factor[30], f_sz, factor_exp[30];
void get_factor(LL x) {
    f_sz = 0;
    LL t = sqrt(x + 0.5);
    for (LL i = 0; pr[i] &lt;= t; ++i)
        if (x % pr[i] == 0) {
            factor_exp[f_sz] = 0;
            while (x % pr[i] == 0) {
                x /= pr[i];
                ++factor_exp[f_sz];
            }
            factor[f_sz++] = pr[i];
        }
    if (x &gt; 1) {
        factor_exp[f_sz] = 1;
        factor[f_sz++] = x;
    }
}
</code></pre>
<ul>
<li>不带指数</li>
</ul>
<pre><code class="language-cpp">LL factor[30], f_sz;
void get_factor(LL x) {
    f_sz = 0;
    LL t = sqrt(x + 0.5);
    for (LL i = 0; pr[i] &lt;= t; ++i)
        if (x % pr[i] == 0) {
            factor[f_sz++] = pr[i];
            while (x % pr[i] == 0) x /= pr[i];
        }
    if (x &gt; 1) factor[f_sz++] = x;
}
</code></pre>
<h2 id="_18">原根</h2>
<ul>
<li>前置模板：素数筛，快速幂，分解质因数</li>
<li>要求 p 为质数</li>
</ul>
<pre><code class="language-cpp">LL find_smallest_primitive_root(LL p) {
    get_factor(p - 1);
    FOR (i, 2, p) {
        bool flag = true;
        FOR (j, 0, f_sz)
            if (bin(i, (p - 1) / factor[j], p) == 1) {
                flag = false;
                break;
            }
        if (flag) return i;
    }
    assert(0); return -1;
}
</code></pre>
<h2 id="_19">公式</h2>
<h3 id="_20">一些数论公式</h3>
<ul>
<li>当 $x\geq\phi(p)$ 时有 $a^x\equiv a^{x \; mod \; \phi(p) + \phi(p)}\pmod p$</li>
<li>$\mu^2(n)=\sum_{d^2|n} \mu(d)$</li>
<li>$\sum_{d|n} \varphi(d)=n$</li>
<li>$\sum_{d|n} 2^{\omega(d)}=\sigma_0(n^2)$，其中 $\omega$ 是不同素因子个数</li>
<li>$\sum_{d|n} \mu^2(d)=2^{\omega(d)}$</li>
</ul>
<h3 id="_21">一些数论函数求和的例子</h3>
<ul>
<li>$\sum_{i=1}^n i[gcd(i, n)=1] = \frac {n \varphi(n) + [n=1]}{2}$</li>
<li>$\sum_{i=1}^n \sum_{j=1}^m [gcd(i,j)=x]=\sum_d \mu(d) \lfloor \frac n {dx} \rfloor  \lfloor \frac m {dx} \rfloor$</li>
<li>$\sum_{i=1}^n \sum_{j=1}^m gcd(i, j) = \sum_{i=1}^n \sum_{j=1}^m \sum_{d|gcd(i,j)} \varphi(d) = \sum_{d} \varphi(d) \lfloor \frac nd \rfloor \lfloor \frac md \rfloor$</li>
<li>$S(n)=\sum_{i=1}^n \mu(i)=1-\sum_{i=1}^n \sum_{d|i,d &lt; i}\mu(d) \overset{t=\frac id}{=} 1-\sum_{t=2}^nS(\lfloor \frac nt \rfloor)$</li>
<li>利用 $[n=1] = \sum_{d|n} \mu(d)$</li>
<li>$S(n)=\sum_{i=1}^n \varphi(i)=\sum_{i=1}^n i-\sum_{i=1}^n \sum_{d|i,d&lt;i} \varphi(i)\overset{t=\frac id}{=} \frac {i(i+1)}{2} - \sum_{t=2}^n S(\frac n t)$</li>
<li>利用 $n = \sum_{d|n} \varphi(d)$</li>
<li>$\sum_{i=1}^n \mu^2(i) = \sum_{i=1}^n \sum_{d^2|n} \mu(d)=\sum_{d=1}^{\lfloor \sqrt n \rfloor}\mu(d) \lfloor \frac n {d^2} \rfloor$ </li>
<li>$\sum_{i=1}^n \sum_{j=1}^n gcd^2(i, j)= \sum_{d} d^2 \sum_{t} \mu(t) \lfloor \frac n{dt} \rfloor ^2 \
  \overset{x=dt}{=} \sum_{x} \lfloor \frac nx \rfloor ^ 2 \sum_{d|x} d^2 \mu(\frac xd)$</li>
<li>$\sum_{i=1}^n \varphi(i)=\frac 12 \sum_{i=1}^n \sum_{j=1}^n [i \perp j] - 1=\frac 12 \sum_{i=1}^n \mu(i) \cdot\lfloor \frac n i \rfloor ^2-1$</li>
</ul>
<h3 id="_22">斐波那契数列性质</h3>
<ul>
<li>$F_{a+b}=F_{a-1} \cdot F_b+F_a \cdot F_{b+1}$</li>
<li>$F_1+F_3+\dots +F_{2n-1} = F_{2n},F_2 + F_4 + \dots + F_{2n} = F_{2n + 1} - 1$</li>
<li>$\sum_{i=1}^n F_i = F_{n+2} - 1$</li>
<li>$\sum_{i=1}^n F_i^2 = F_n \cdot F_{n+1}$</li>
<li>$F_n^2=(-1)^{n-1} + F_{n-1} \cdot F_{n+1}$</li>
<li>$gcd(F_a, F_b)=F_{gcd(a, b)}$</li>
<li>模 $n$ 周期（皮萨诺周期）</li>
<li>$\pi(p^k) = p^{k-1} \pi(p)$</li>
<li>$\pi(nm) = lcm(\pi(n), \pi(m)), \forall n \perp m$</li>
<li>$\pi(2)=3, \pi(5)=20$</li>
<li>$\forall p \equiv \pm 1\pmod {10}, \pi(p)|p-1$</li>
<li>$\forall p \equiv \pm 2\pmod {5}, \pi(p)|2p+2$</li>
</ul>
<h3 id="_23">常见生成函数</h3>
<ul>
<li>$(1+ax)^n=\sum_{k=0}^n \binom {n}{k} a^kx^k$</li>
<li>$\dfrac{1-x^{r+1}}{1-x}=\sum_{k=0}^nx^k$</li>
<li>$\dfrac1{1-ax}=\sum_{k=0}^{\infty}a^kx^k$</li>
<li>$\dfrac 1{(1-x)^2}=\sum_{k=0}^{\infty}(k+1)x^k$</li>
<li>$\dfrac1{(1-x)^n}=\sum_{k=0}^{\infty} \binom{n+k-1}{k}x^k$</li>
<li>$e^x=\sum_{k=0}^{\infty}\dfrac{x^k}{k!}$</li>
<li>$\ln(1+x)=\sum_{k=0}^{\infty}\dfrac{(-1)^{k+1}}{k}x^k$</li>
</ul>
<h3 id="_24">佩尔方程</h3>
<p>若一个丢番图方程具有以下的形式：$x^2 - ny^2= 1$。且 $n$ 为正整数，则称此二元二次不定方程为<strong>佩尔方程</strong>。</p>
<p>若 $n$ 是完全平方数，则这个方程式只有平凡解 $(\pm 1,0)$（实际上对任意的 $n$，$(\pm 1,0)$ 都是解）。对于其余情况，拉格朗日证明了佩尔方程总有非平凡解。而这些解可由 $\sqrt{n}$ 的连分数求出。</p>
<p>$x = [a_0; a_1, a_2, a_3]=x = a_0 + \cfrac{1}{a_1 + \cfrac{1}{a_2 + \cfrac{1}{a_3 + \cfrac{1}{\ddots\,}}}}$</p>
<p>设 $\tfrac{p_i}{q_i}$ 是 $\sqrt{n}$ 的连分数表示：$[a_{0}; a_{1}, a_{2}, a_{3}, \,\ldots ]$ 的渐近分数列，由连分数理论知存在 $i$ 使得 $(p_i,q_i)$ 为佩尔方程的解。取其中最小的 $i$，将对应的 $(p_i,q_i)$ 称为佩尔方程的基本解，或最小解，记作 $(x_1,y_1)$，则所有的解 $(x_i,y_i)$ 可表示成如下形式：$x_{i}+y_{i}{\sqrt  n}=(x_{1}+y_{1}{\sqrt  n})^{i}$。或者由以下的递回关系式得到：</p>
<p>$\displaystyle x_{i+1} = x_1 x_i + n y_1 y_i$, $\displaystyle y_{{i+1}}=x_{1}y_{i}+y_{1}x_{i}$。</p>
<p><strong>但是：</strong>佩尔方程千万不要去推（虽然推起来很有趣，但结果不一定好看，会是两个式子）。记住佩尔方程结果的形式通常是 $a_n=ka_{n−1}−a_{n−2}$（$a_{n−2}$ 前的系数通常是 $−1$）。暴力 / 凑出两个基础解之后加上一个 $0$，容易解出 $k$ 并验证。</p>
<h3 id="burnside-polya">Burnside &amp; Polya</h3>
<ul>
<li>$|X/G|={\frac  {1}{|G|}}\sum _{{g\in G}}|X^{g}|$</li>
</ul>
<p>注：$X^g$ 是 $g$ 下的不动点数量，也就是说有多少种东西用 $g$ 作用之后可以保持不变。</p>
<ul>
<li>$|Y^X/G| = \frac{1}{|G|}\sum_{g \in G} m^{c(g)}$</li>
</ul>
<p>注：用 $m$ 种颜色染色，然后对于某一种置换 $g$，有 $c(g)$ 个置换环，为了保证置换后颜色仍然相同，每个置换环必须染成同色。</p>
<h3 id="_25">皮克定理</h3>
<p>$2S = 2a+b-2$</p>
<ul>
<li>$S$ 多边形面积</li>
<li>$a$ 多边形内部点数</li>
<li>$b$ 多边形边上点数</li>
</ul>
<h3 id="_26">莫比乌斯反演</h3>
<ul>
<li>$g(n) = \sum_{d|n} f(d) \Leftrightarrow f(n) = \sum_{d|n} \mu (d) g( \frac{n}{d})$</li>
<li>$f(n)=\sum_{n|d}g(d) \Leftrightarrow g(n)=\sum_{n|d} \mu(\frac{d}{n}) f(d)$</li>
</ul>
<h3 id="_27">低阶等幂求和</h3>
<ul>
<li>$\sum_{i=1}^{n} i^{1} = \frac{n(n+1)}{2} = \frac{1}{2}n^2 +\frac{1}{2} n$</li>
<li>$\sum_{i=1}^{n} i^{2} = \frac{n(n+1)(2n+1)}{6} = \frac{1}{3}n^3 + \frac{1}{2}n^2 + \frac{1}{6}n$</li>
<li>$\sum_{i=1}^{n} i^{3} = \left[\frac{n(n+1)}{2}\right]^{2} = \frac{1}{4}n^4 + \frac{1}{2}n^3 + \frac{1}{4}n^2$</li>
<li>$\sum_{i=1}^{n} i^{4} = \frac{n(n+1)(2n+1)(3n^2+3n-1)}{30} = \frac{1}{5}n^5 + \frac{1}{2}n^4 + \frac{1}{3}n^3 - \frac{1}{30}n$</li>
<li>$\sum_{i=1}^{n} i^{5} = \frac{n^{2}(n+1)^{2}(2n^2+2n-1)}{12} = \frac{1}{6}n^6 + \frac{1}{2}n^5 + \frac{5}{12}n^4 - \frac{1}{12}n^2$</li>
</ul>
<h3 id="_28">一些组合公式</h3>
<ul>
<li>错排公式：$D_1=0,D_2=1,D_n=(n-1)(D_{n-1} + D_{n-2})=n!(\frac 1{2!}-\frac 1{3!}+\dots + (-1)^n\frac 1{n!})=\lfloor \frac{n!}e + 0.5 \rfloor$</li>
<li>卡塔兰数（$n$ 对括号合法方案数，$n$ 个结点二叉树个数，$n\times n$ 方格中对角线下方的单调路径数，凸 $n+2$ 边形的三角形划分数，$n$ 个元素的合法出栈序列数）：$C_n=\frac 1{n+1}\binom {2n}n=\frac{(2n)!}{(n+1)!n!}$</li>
</ul>
<h2 id="_29">二次剩余</h2>
<p>URAL 1132</p>
<pre><code class="language-cpp">LL q1, q2, w;
struct P { // x + y * sqrt(w)
    LL x, y;
};

P pmul(const P&amp; a, const P&amp; b, LL p) {
    P res;
    res.x = (a.x * b.x + a.y * b.y % p * w) % p;
    res.y = (a.x * b.y + a.y * b.x) % p;
    return res;
}

P bin(P x, LL n, LL MOD) {
    P ret = {1, 0};
    for (; n; n &gt;&gt;= 1, x = pmul(x, x, MOD))
        if (n &amp; 1) ret = pmul(ret, x, MOD);
    return ret;
}
LL Legendre(LL a, LL p) { return bin(a, (p - 1) &gt;&gt; 1, p); }

LL equation_solve(LL b, LL p) {
    if (p == 2) return 1;
    if ((Legendre(b, p) + 1) % p == 0)
        return -1;
    LL a;
    while (true) {
        a = rand() % p;
        w = ((a * a - b) % p + p) % p;
        if ((Legendre(w, p) + 1) % p == 0)
            break;
    }
    return bin({a, 1}, (p + 1) &gt;&gt; 1, p).x;
}

int main() {
    int T; cin &gt;&gt; T;
    while (T--) {
        LL a, p; cin &gt;&gt; a &gt;&gt; p;
        a = a % p;
        LL x = equation_solve(a, p);
        if (x == -1) {
            puts(&quot;No root&quot;);
        } else {
            LL y = p - x;
            if (x == y) cout &lt;&lt; x &lt;&lt; endl;
            else cout &lt;&lt; min(x, y) &lt;&lt; &quot; &quot; &lt;&lt; max(x, y) &lt;&lt; endl;
        }
    }
}
</code></pre>
<h2 id="_30">中国剩余定理</h2>
<ul>
<li>无解返回 -1</li>
<li>前置模板：扩展欧几里得</li>
</ul>
<pre><code class="language-cpp">LL CRT(LL *m, LL *r, LL n) {
    if (!n) return 0;
    LL M = m[0], R = r[0], x, y, d;
    FOR (i, 1, n) {
        d = ex_gcd(M, m[i], x, y);
        if ((r[i] - R) % d) return -1;
        x = (r[i] - R) / d * x % (m[i] / d);
        // 防爆 LL
        // x = mul((r[i] - R) / d, x, m[i] / d);
        R += x * M;
        M = M / d * m[i];
        R %= M;
    }
    return R &gt;= 0 ? R : R + M;
}

</code></pre>
<h2 id="_31">伯努利数和等幂求和</h2>
<ul>
<li>预处理逆元</li>
<li>预处理组合数</li>
<li>$\sum_{i=0}^n i^k = \frac{1}{k+1} \sum_{i=0}^k \binom{k+1}{i} B_{k+1-i} (n+1)^i$.</li>
<li>也可以 $\sum_{i=0}^n i^k = \frac{1}{k+1} \sum_{i=0}^k \binom{k+1}{i} B^+_{k+1-i} n^i$。区别在于 $B^+_1 =1/2$。(心态崩了)</li>
</ul>
<pre><code class="language-cpp">namespace Bernoulli {
    const int M = 100;
    LL inv[M] = {-1, 1};
    void inv_init(LL n, LL p) {
        FOR (i, 2, n)
            inv[i] = (p - p / i) * inv[p % i] % p;
    }

    LL C[M][M];
    void init_C(int n) {
        FOR (i, 0, n) {
            C[i][0] = C[i][i] = 1;
            FOR (j, 1, i)
                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
        }
    }

    LL B[M] = {1};
    void init() {
        inv_init(M, MOD);
        init_C(M);
        FOR (i, 1, M - 1) {
            LL&amp; s = B[i] = 0;
            FOR (j, 0, i)
                s += C[i + 1][j] * B[j] % MOD;
            s = (s % MOD * -inv[i + 1] % MOD + MOD) % MOD;
        }
    }

    LL p[M] = {1};
    LL go(LL n, LL k) {
        n %= MOD;
        if (k == 0) return n;
        FOR (i, 1, k + 2)
            p[i] = p[i - 1] * (n + 1) % MOD;
        LL ret = 0;
        FOR (i, 1, k + 2)
            ret += C[k + 1][i] * B[k + 1 - i] % MOD * p[i] % MOD;
        ret = ret % MOD * inv[k + 1] % MOD;
        return ret;
    }
}
</code></pre>
<h2 id="_32">单纯形</h2>
<ul>
<li>要求有基本解，也就是 x 为零向量可行</li>
<li>v 要初始化为 0，n 表示向量长度，m 表示约束个数</li>
</ul>
<pre><code class="language-cpp">// min{ b x } / max { c x }
// A x &gt;= c   / A x &lt;= b
// x &gt;= 0
namespace lp {
    int n, m;
    double a[M][N], b[M], c[N], v;

    void pivot(int l, int e) {
        b[l] /= a[l][e];
        FOR (j, 0, n) if (j != e) a[l][j] /= a[l][e];
        a[l][e] = 1 / a[l][e];

        FOR (i, 0, m)
            if (i != l &amp;&amp; fabs(a[i][e]) &gt; 0) {
                b[i] -= a[i][e] * b[l];
                FOR (j, 0, n)
                    if (j != e) a[i][j] -= a[i][e] * a[l][j];
                a[i][e] = -a[i][e] * a[l][e];
            }
        v += c[e] * b[l];
        FOR (j, 0, n) if (j != e) c[j] -= c[e] * a[l][j];
        c[e] = -c[e] * a[l][e];
    }
    double simplex() {
        while (1) {
            v = 0;
            int e = -1, l = -1;
            FOR (i, 0, n) if (c[i] &gt; eps) { e = i; break; }
            if (e == -1) return v;
            double t = INF;
            FOR (i, 0, m)
                if (a[i][e] &gt; eps &amp;&amp; t &gt; b[i] / a[i][e]) {
                    t = b[i] / a[i][e];
                    l = i;
                }
            if (l == -1) return INF;
            pivot(l, e);
        }
    }
}
</code></pre>
<h2 id="_33">离散对数</h2>
<h3 id="bsgs">BSGS</h3>
<ul>
<li>模数为素数</li>
</ul>
<pre><code class="language-cpp">LL BSGS(LL a, LL b, LL p) { // a^x = b (mod p)
    a %= p;
    if (!a &amp;&amp; !b) return 1;
    if (!a) return -1;
    static map&lt;LL, LL&gt; mp; mp.clear();
    LL m = sqrt(p + 1.5);
    LL v = 1;
    FOR (i, 1, m + 1) {
        v = v * a % p;
        mp[v * b % p] = i;
    }
    LL vv = v;
    FOR (i, 1, m + 1) {
        auto it = mp.find(vv);
        if (it != mp.end()) return i * m - it-&gt;second;
        vv = vv * v % p;
    }
    return -1;
}
</code></pre>
<h3 id="exbsgs">exBSGS</h3>
<ul>
<li>模数可以非素数</li>
</ul>
<pre><code class="language-cpp">LL exBSGS(LL a, LL b, LL p) { // a^x = b (mod p)
    a %= p; b %= p;
    if (a == 0) return b &gt; 1 ? -1 : b == 0 &amp;&amp; p != 1;
    LL c = 0, q = 1;
    while (1) {
        LL g = __gcd(a, p);
        if (g == 1) break;
        if (b == 1) return c;
        if (b % g) return -1;
        ++c; b /= g; p /= g; q = a / g * q % p;
    }
    static map&lt;LL, LL&gt; mp; mp.clear();
    LL m = sqrt(p + 1.5);
    LL v = 1;
    FOR (i, 1, m + 1) {
        v = v * a % p;
        mp[v * b % p] = i;
    }
    FOR (i, 1, m + 1) {
        q = q * v % p;
        auto it = mp.find(q);
        if (it != mp.end()) return i * m - it-&gt;second + c;
    }
    return -1;
}
</code></pre>
<h2 id="_34">数论分块</h2>
<p>$f(i) = \lfloor \frac{n}{i} \rfloor=v$ 时 $i$ 的取值范围是 $[l,r]$。</p>
<pre><code class="language-cpp">for (LL l = 1, v, r; l &lt;= N; l = r + 1) {
    v = N / l; r = N / v;
}
</code></pre>
<h2 id="_35">博弈</h2>
<ul>
<li>Nim 游戏：每轮从若干堆石子中的一堆取走若干颗。先手必胜条件为石子数量异或和非零。</li>
<li>阶梯 Nim 游戏：可以选择阶梯上某一堆中的若干颗向下推动一级，直到全部推下去。先手必胜条件是奇数阶梯的异或和非零（对于偶数阶梯的操作可以模仿）。</li>
<li>Anti-SG：无法操作者胜。先手必胜的条件是：</li>
<li>SG 不为 0 且某个单一游戏的 SG 大于 1 。</li>
<li>SG 为 0 且没有单一游戏的 SG 大于 1。</li>
<li>Every-SG：对所有单一游戏都要操作。先手必胜的条件是单一游戏中的最大 step 为奇数。</li>
<li>对于终止状态 step 为 0</li>
<li>对于 SG 为 0 的状态，step 是最大后继 step +1</li>
<li>对于 SG 非 0 的状态，step 是最小后继 step +1</li>
<li>树上删边：叶子 SG 为 0，非叶子结点为所有子结点的 SG 值加 1 后的异或和。</li>
</ul>
<p>尝试：</p>
<ul>
<li>打表找规律</li>
<li>寻找一类必胜态（如对称局面）</li>
<li>直接博弈 dp</li>
</ul></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../../../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../../../../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../../../../../js/base.js"></script>
        <script src="../../../../../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
