<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../../../../../img/favicon.ico">
        <title>字符串 - 勿怯 勿惰 勿贪 勿我</title>
        <link href="../../../../../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../../../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../../../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../../../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../../../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../../../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../../../../../..">勿怯 勿惰 勿贪 勿我</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../../../../../../.." class="nav-link">个人首页</a>
                            </li>
                            <li class="nav-item">
                                <a href="../../../../../../../about/" class="nav-link">工具链接网址</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">清华</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../thu/" class="dropdown-item">清华</a>
</li>
                                    
<li>
    <a href="../../../../../../d1/d1/" class="dropdown-item">大一</a>
</li>
                                    
<li>
    <a href="../../../../../d2/" class="dropdown-item">大二</a>
</li>
                                    
<li>
    <a href="../../../../../../d3/d3/" class="dropdown-item">大三</a>
</li>
                                    
<li>
    <a href="../../../../../../d4/d4/" class="dropdown-item">大四</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">数学</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../math/math/" class="dropdown-item">数学</a>
</li>
                                    
<li>
    <a href="../../../../../../../math/caculus/" class="dropdown-item">微积分</a>
</li>
                                    
<li>
    <a href="../../../../../../../math/linear/" class="dropdown-item">线性代数</a>
</li>
                                    
<li>
    <a href="../../../../../../../math/probability/" class="dropdown-item">概率论</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">计算机</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../cs/cs/" class="dropdown-item">计算机</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">编程语言</a>
    <ul class="dropdown-menu">
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">C语言</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/c/" class="dropdown-item">C</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">C++语言</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp/cpp/" class="dropdown-item">C++</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">数据结构</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/dsa/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">操作系统</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/os/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">计算机组成原理</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/jz/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">计算机网络</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/jw/" class="dropdown-item">总述</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">金融量化</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../finance/finance/" class="dropdown-item">金融</a>
</li>
                                    
<li>
    <a href="../../../../../../../finance/crypto/crypto/" class="dropdown-item">币</a>
</li>
                                    
<li>
    <a href="../../../../../../../finance/stock/stock/" class="dropdown-item">股票</a>
</li>
                                    
<li>
    <a href="../../../../../../../finance/quant/quant/" class="dropdown-item">量化</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">艺体</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../art/art/" class="dropdown-item">文学</a>
</li>
                                    
<li>
    <a href="../../../../../../../art/English/english/" class="dropdown-item">英语</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">读书</a>
    <ul class="dropdown-menu">
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">计算机</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../books/cs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/lan/" class="dropdown-item">编程语言</a>
</li>
    </ul>
  </li>
            
<li>
    <a href="../../../../../../../books/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/gr/" class="dropdown-item">个人成长</a>
</li>
            
<li>
    <a href="../../../../../../../books/navy/zashu/" class="dropdown-item">杂书</a>
</li>
    </ul>
  </li>
                                    
<li>
    <a href="../../../../../../../art/music/" class="dropdown-item">音乐</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">生活记录</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../../../../../me/dgh/" class="dropdown-item">我是谁</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">2024</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2024/2024/" class="dropdown-item">2024年</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">8月</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%886%E6%97%A5/" class="dropdown-item">2024年8月6日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%887%E6%97%A5/" class="dropdown-item">2024年8月7日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%888%E6%97%A5/" class="dropdown-item">2024年8月8日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%889%E6%97%A5/" class="dropdown-item">2024年8月9日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8810%E6%97%A5/" class="dropdown-item">2024年8月10日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8811%E6%97%A5/" class="dropdown-item">2024年8月11日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8812%E6%97%A5/" class="dropdown-item">2024年8月12日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8813%E6%97%A5/" class="dropdown-item">2024年8月13日</a>
</li>
            
<li>
    <a href="../../../../../../../me/2024/8/2024%E5%B9%B48%E6%9C%8814%E6%97%A5/" class="dropdown-item">2024年8月14日</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">11月</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2024/11/2024%E5%B9%B411%E6%9C%8828%E6%97%A5/" class="dropdown-item">2024年11月28日</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">2025</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../../../../../../me/2025/2025%E5%B9%B4/" class="dropdown-item">2025年</a>
</li>
            
<li>
    <a href="../../../../../../../me/2025/1%E6%9C%88/2025%E5%B9%B41%E6%9C%88/" class="dropdown-item">2025年1月</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#_1" class="nav-link">字符串</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">后缀自动机</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_3" class="nav-link">回文自动机</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#manacher" class="nav-link">manacher</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_4" class="nav-link">哈希</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_5" class="nav-link">后缀数组</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#kmp" class="nav-link">KMP</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#trie" class="nav-link">Trie</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#ac" class="nav-link">AC 自动机</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="_1">字符串</h1>
<h2 id="_2">后缀自动机</h2>
<p><img alt="" src="../assets/sam.png" /></p>
<ul>
<li>广义后缀自动机如果直接使用以下代码的话会产生一些冗余状态（置 last 为 1），所以要用拓扑排序。用 len 基数排序不能。</li>
<li>字符集大的话要使用<code>map</code>。</li>
<li>树上 dp 时注意边界（root 和 null）。</li>
<li>rsort 中的数组 a 是拓扑序 [1, sz)</li>
</ul>
<pre><code class="language-cpp">namespace sam {
    const int M = N &lt;&lt; 1;
    int t[M][26], len[M] = {-1}, fa[M], sz = 2, last = 1;
    void init() { memset(t, 0, (sz + 10) * sizeof t[0]); sz = 2; last = 1; }
    void ins(int ch) {
        int p = last, np = last = sz++;
        len[np] = len[p] + 1;
        for (; p &amp;&amp; !t[p][ch]; p = fa[p]) t[p][ch] = np;
        if (!p) { fa[np] = 1; return; }
        int q = t[p][ch];
        if (len[p] + 1 == len[q]) fa[np] = q;
        else {
            int nq = sz++; len[nq] = len[p] + 1;
            memcpy(t[nq], t[q], sizeof t[0]);
            fa[nq] = fa[q];
            fa[np] = fa[q] = nq;
            for (; t[p][ch] == q; p = fa[p]) t[p][ch] = nq;
        }
    }

    int c[M] = {1}, a[M];
    void rsort() {
        FOR (i, 1, sz) c[i] = 0;
        FOR (i, 1, sz) c[len[i]]++;
        FOR (i, 1, sz) c[i] += c[i - 1];
        FOR (i, 1, sz) a[--c[len[i]]] = i;
    }
}
</code></pre>
<ul>
<li>真·广义后缀自动机</li>
</ul>
<pre><code class="language-cpp">int t[M][26], len[M] = {-1}, fa[M], sz = 2, last = 1;
LL cnt[M][2];
void ins(int ch, int id) {
    int p = last, np = 0, nq = 0, q = -1;
    if (!t[p][ch]) {
        np = sz++;
        len[np] = len[p] + 1;
        for (; p &amp;&amp; !t[p][ch]; p = fa[p]) t[p][ch] = np;
    }
    if (!p) fa[np] = 1;
    else {
        q = t[p][ch];
        if (len[p] + 1 == len[q]) fa[np] = q;
        else {
            nq = sz++; len[nq] = len[p] + 1;
            memcpy(t[nq], t[q], sizeof t[0]);
            fa[nq] = fa[q];
            fa[np] = fa[q] = nq;
            for (; t[p][ch] == q; p = fa[p]) t[p][ch] = nq;
        }
    }
    last = np ? np : nq ? nq : q;
    cnt[last][id] = 1;
}
</code></pre>
<ul>
<li>按字典序建立后缀树 注意逆序插入</li>
<li>rsort2 里的 a 不是拓扑序，需要拓扑序就去树上做</li>
</ul>
<pre><code class="language-cpp">void ins(int ch, int pp) {
    int p = last, np = last = sz++;
    len[np] = len[p] + 1; one[np] = pos[np] = pp;
    for (; p &amp;&amp; !t[p][ch]; p = fa[p]) t[p][ch] = np;
    if (!p) { fa[np] = 1; return; }
    int q = t[p][ch];
    if (len[q] == len[p] + 1) fa[np] = q;
    else {
        int nq = sz++; len[nq] = len[p] + 1; one[nq] = one[q];
        memcpy(t[nq], t[q], sizeof t[0]);
        fa[nq] = fa[q];
        fa[q] = fa[np] = nq;
        for (; p &amp;&amp; t[p][ch] == q; p = fa[p]) t[p][ch] = nq;
    }
}

int up[M], c[256] = {2}, a[M];
void rsort2() {
    FOR (i, 1, 256) c[i] = 0;
    FOR (i, 2, sz) up[i] = s[one[i] + len[fa[i]]];
    FOR (i, 2, sz) c[up[i]]++;
    FOR (i, 1, 256) c[i] += c[i - 1];
    FOR (i, 2, sz) a[--c[up[i]]] = i;
    FOR (i, 2, sz) G[fa[a[i]]].push_back(a[i]);
}
</code></pre>
<ul>
<li>广义后缀自动机建后缀树，必须反向插入</li>
</ul>
<pre><code class="language-cpp">int t[M][26], len[M] = {0}, fa[M], sz = 2, last = 1;
char* one[M];
void ins(int ch, char* pp) {
    int p = last, np = 0, nq = 0, q = -1;
    if (!t[p][ch]) {
        np = sz++; one[np] = pp;
        len[np] = len[p] + 1;
        for (; p &amp;&amp; !t[p][ch]; p = fa[p]) t[p][ch] = np;
    }
    if (!p) fa[np] = 1;
    else {
        q = t[p][ch];
        if (len[p] + 1 == len[q]) fa[np] = q;
        else {
            nq = sz++; len[nq] = len[p] + 1; one[nq] = one[q];
            memcpy(t[nq], t[q], sizeof t[0]);
            fa[nq] = fa[q];
            fa[np] = fa[q] = nq;
            for (; t[p][ch] == q; p = fa[p]) t[p][ch] = nq;
        }
    }
    last = np ? np : nq ? nq : q;
}
int up[M], c[256] = {2}, aa[M];
vector&lt;int&gt; G[M];
void rsort() {
    FOR (i, 1, 256) c[i] = 0;
    FOR (i, 2, sz) up[i] = *(one[i] + len[fa[i]]);
    FOR (i, 2, sz) c[up[i]]++;
    FOR (i, 1, 256) c[i] += c[i - 1];
    FOR (i, 2, sz) aa[--c[up[i]]] = i;
    FOR (i, 2, sz) G[fa[aa[i]]].push_back(aa[i]);
}
</code></pre>
<ul>
<li>匹配</li>
</ul>
<pre><code class="language-cpp">int u = 1, l = 0;
FOR (i, 0, strlen(s)) {
    int ch = s[i] - 'a';
    while (u &amp;&amp; !t[u][ch]) { u = fa[u]; l = len[u]; }
    ++l; u = t[u][ch];
    if (!u) u = 1;
    if (l) // do something...
}
</code></pre>
<ul>
<li>获取子串状态</li>
</ul>
<pre><code class="language-cpp">int get_state(int l, int r) {
    int u = rpos[r], s = r - l + 1;
    FORD (i, SP - 1, -1) if (len[pa[u][i]] &gt;= s) u = pa[u][i];
    return u;
}
</code></pre>
<ul>
<li>配合 LCT</li>
</ul>
<pre><code class="language-cpp">namespace lct_sam {
    extern struct P *const null;
    const int M = N;
    struct P {
        P *fa, *ls, *rs;
        int last;

        bool has_fa() { return fa-&gt;ls == this || fa-&gt;rs == this; }
        bool d() { return fa-&gt;ls == this; }
        P*&amp; c(bool x) { return x ? ls : rs; }
        P* up() { return this; }
        void down() {
            if (ls != null) ls-&gt;last = last;
            if (rs != null) rs-&gt;last = last;
        }
        void all_down() { if (has_fa()) fa-&gt;all_down(); down(); }
    } *const null = new P{0, 0, 0, 0}, pool[M], *pit = pool;
    P* G[N];
    int t[M][26], len[M] = {-1}, fa[M], sz = 2, last = 1;

    void rot(P* o) {
        bool dd = o-&gt;d();
        P *f = o-&gt;fa, *t = o-&gt;c(!dd);
        if (f-&gt;has_fa()) f-&gt;fa-&gt;c(f-&gt;d()) = o; o-&gt;fa = f-&gt;fa;
        if (t != null) t-&gt;fa = f; f-&gt;c(dd) = t;
        o-&gt;c(!dd) = f-&gt;up(); f-&gt;fa = o;
    }
    void splay(P* o) {
        o-&gt;all_down();
        while (o-&gt;has_fa()) {
            if (o-&gt;fa-&gt;has_fa())
                rot(o-&gt;d() ^ o-&gt;fa-&gt;d() ? o : o-&gt;fa);
            rot(o);
        }
        o-&gt;up();
    }
    void access(int last, P* u, P* v = null) {
        if (u == null) { v-&gt;last = last; return; }
        splay(u);
        P *t = u;
        while (t-&gt;ls != null) t = t-&gt;ls;
        int L = len[fa[t - pool]] + 1, R = len[u - pool];

        if (u-&gt;last) bit::add(u-&gt;last - R + 2, u-&gt;last - L + 2, 1);
        else bit::add(1, 1, R - L + 1);
        bit::add(last - R + 2, last - L + 2, -1);

        u-&gt;rs = v;
        access(last, u-&gt;up()-&gt;fa, u);
    }
    void insert(P* u, P* v, P* t) {
        if (v != null) { splay(v); v-&gt;rs = null; }
        splay(u);
        u-&gt;fa = t; t-&gt;fa = v;
    }

    void ins(int ch, int pp) {
        int p = last, np = last = sz++;
        len[np] = len[p] + 1;
        for (; p &amp;&amp; !t[p][ch]; p = fa[p]) t[p][ch] = np;
        if (!p) fa[np] = 1;
        else {
            int q = t[p][ch];
            if (len[p] + 1 == len[q]) { fa[np] = q; G[np]-&gt;fa = G[q]; }
            else {
                int nq = sz++; len[nq] = len[p] + 1;
                memcpy(t[nq], t[q], sizeof t[0]);
                insert(G[q], G[fa[q]], G[nq]);
                G[nq]-&gt;last = G[q]-&gt;last;
                fa[nq] = fa[q];
                fa[np] = fa[q] = nq;
                G[np]-&gt;fa = G[nq];
                for (; t[p][ch] == q; p = fa[p]) t[p][ch] = nq;
            }
        }
        access(pp + 1, G[np]);
    }

    void init() {
        ++pit;
        FOR (i, 1, N) {
            G[i] = pit++;
            G[i]-&gt;ls = G[i]-&gt;rs = G[i]-&gt;fa = null;
        }
        G[1] = null;
    }
}
</code></pre>
<h2 id="_3">回文自动机</h2>
<ul>
<li>num 是该结点表示的前缀的回文后缀个数</li>
<li>cnt 是该结点表示的回文串在原串中的出现次数（使用前需要向父亲更新）</li>
</ul>
<pre><code class="language-cpp">namespace pam {
    int t[N][26], fa[N], len[N], rs[N], cnt[N], num[N];
    int sz, n, last;
    int _new(int l) {
        len[sz] = l; cnt[sz] = num[sz] = 0;
        return sz++;
    }
    void init() {
        memset(t, 0, sz * sizeof t[0]);
        rs[n = sz = 0] = -1;
        last = _new(0);
        fa[last] = _new(-1);
    }
    int get_fa(int x) {
        while (rs[n - 1 - len[x]] != rs[n]) x = fa[x];
        return x;
    }
    void ins(int ch) {
        rs[++n] = ch;
        int p = get_fa(last);
        if (!t[p][ch]) {
            int np = _new(len[p] + 2);
            num[np] = num[fa[np] = t[get_fa(fa[p])][ch]] + 1;
            t[p][ch] = np;
        }
        ++cnt[last = t[p][ch]];
    }
}
</code></pre>
<h2 id="manacher">manacher</h2>
<pre><code class="language-cpp">int RL[N];
void manacher(int* a, int n) { // &quot;abc&quot; =&gt; &quot;#a#b#a#&quot;
    int r = 0, p = 0;
    FOR (i, 0, n) {
        if (i &lt; r) RL[i] = min(RL[2 * p - i], r - i);
        else RL[i] = 1;
        while (i - RL[i] &gt;= 0 &amp;&amp; i + RL[i] &lt; n &amp;&amp; a[i - RL[i]] == a[i + RL[i]])
            RL[i]++;
        if (RL[i] + i - 1 &gt; r) { r = RL[i] + i - 1; p = i; }
    }
    FOR (i, 0, n) --RL[i];
}

</code></pre>
<h2 id="_4">哈希</h2>
<p>内置了自动双哈希开关（小心 TLE）。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

#define ENABLE_DOUBLE_HASH

typedef long long LL;
typedef unsigned long long ULL;

const int x = 135;
const int N = 4e5 + 10;
const int p1 = 1e9 + 7, p2 = 1e9 + 9;
ULL xp1[N], xp2[N], xp[N];

void init_xp() {
    xp1[0] = xp2[0] = xp[0] = 1;
    for (int i = 1; i &lt; N; ++i) {
        xp1[i] = xp1[i - 1] * x % p1;
        xp2[i] = xp2[i - 1] * x % p2;
        xp[i] = xp[i - 1] * x;
    }
}

struct String {
    char s[N];
    int length, subsize;
    bool sorted;
    ULL h[N], hl[N];

    ULL hash() {
        length = strlen(s);
        ULL res1 = 0, res2 = 0;
        h[length] = 0;  // ATTENTION!
        for (int j = length - 1; j &gt;= 0; --j) {
        #ifdef ENABLE_DOUBLE_HASH
            res1 = (res1 * x + s[j]) % p1;
            res2 = (res2 * x + s[j]) % p2;
            h[j] = (res1 &lt;&lt; 32) | res2;
        #else
            res1 = res1 * x + s[j];
            h[j] = res1;
        #endif
            // printf(&quot;%llu\n&quot;, h[j]);
        }
        return h[0];
    }

    // 获取子串哈希，左闭右开区间
    ULL get_substring_hash(int left, int right) const {
        int len = right - left;
    #ifdef ENABLE_DOUBLE_HASH
        // get hash of s[left...right-1]
        unsigned int mask32 = ~(0u);
        ULL left1 = h[left] &gt;&gt; 32, right1 = h[right] &gt;&gt; 32;
        ULL left2 = h[left] &amp; mask32, right2 = h[right] &amp; mask32;
        return (((left1 - right1 * xp1[len] % p1 + p1) % p1) &lt;&lt; 32) |
               (((left2 - right2 * xp2[len] % p2 + p2) % p2));
    #else
        return h[left] - h[right] * xp[len];
    #endif
    }

    void get_all_subs_hash(int sublen) {
        subsize = length - sublen + 1;
        for (int i = 0; i &lt; subsize; ++i)
            hl[i] = get_substring_hash(i, i + sublen);
        sorted = 0;
    }

    void sort_substring_hash() {
        sort(hl, hl + subsize);
        sorted = 1;
    }

    bool match(ULL key) const {
        if (!sorted) assert (0);
        if (!subsize) return false;
        return binary_search(hl, hl + subsize, key);
    }

    void init(const char *t) {
        length = strlen(t);
        strcpy(s, t);
    }
};

int LCP(const String &amp;a, const String &amp;b, int ai, int bi) {
    // Find LCP of a[ai...] and b[bi...]
    int l = 0, r = min(a.length - ai, b.length - bi);
    while (l &lt; r) {
        int mid = (l + r + 1) / 2;
        if (a.get_substring_hash(ai, ai + mid) == b.get_substring_hash(bi, bi + mid))
            l = mid;
        else r = mid - 1;
    }
    return l;
}

int check(int ans) {
    if (T.length &lt; ans) return 1;
    T.get_all_subs_hash(ans); T.sort_substring_hash();
    for (int i = 0; i &lt; S.length - ans + 1; ++i)
        if (!T.match(S.get_substring_hash(i, i + ans)))
            return 1;
    return 0;
}

int main() {
    init_xp();  // DON'T FORGET TO DO THIS!

    for (int tt = 1; tt &lt;= kases; ++tt) {
        scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, str);
        S.init(str);
        S.hash(); T.hash();
    }
}
</code></pre>
<p>二维哈希</p>
<pre><code class="language-cpp">struct Hash2D { // 1-index
    static const LL px = 131, py = 233, MOD = 998244353;
    static LL pwx[N], pwy[N];
    int a[N][N];
    LL hv[N][N];
    static void init_xp() {
        pwx[0] = pwy[0] = 1;
        FOR (i, 1, N) {
            pwx[i] = pwx[i - 1] * px % MOD;
            pwy[i] = pwy[i - 1] * py % MOD;
        }
    }
    void init_hash(int n, int m) {
        FOR (i, 1, n + 1) {
            LL s = 0;
            FOR (j, 1, m + 1) {
                s = (s * py + a[i][j]) % MOD;
                hv[i][j] = (hv[i - 1][j] * px + s) % MOD;
            }
        }
    }
    LL h(int x, int y, int dx, int dy) {
        --x; --y;
        LL ret = hv[x + dx][y + dy] + hv[x][y] * pwx[dx] % MOD * pwy[dy]
                 - hv[x][y + dy] * pwx[dx] - hv[x + dx][y] * pwy[dy];
        return (ret % MOD + MOD) % MOD;
    }
} ha, hb;
LL Hash2D::pwx[N], Hash2D::pwy[N];
</code></pre>
<h2 id="_5">后缀数组</h2>
<p>构造时间：$O(L \log L)$；查询时间 $O(\log L)$。<code>suffix</code> 数组是排好序的后缀下标， <code>suffix</code> 的反数组是后缀数组。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 2e5 + 10;
const int Nlog = 18;

struct SuffixArray {
    const int L;
    vector&lt;vector&lt;int&gt; &gt; P;
    vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; M;
    int s[N], sa[N], rank[N], height[N];
    // s: raw string
    // sa[i]=k: s[k...L-1] ranks i (0 based)
    // rank[i]=k: the rank of s[i...L-1] is k (0 based)
    // height[i] = lcp(sa[i-1], sa[i])

    SuffixArray(const string &amp;raw_s) : L(raw_s.length()), P(1, vector&lt;int&gt;(L, 0)), M(L) {
        for (int i = 0; i &lt; L; i++)
            P[0][i] = this-&gt;s[i] = int(raw_s[i]);
        for (int skip = 1, level = 1; skip &lt; L; skip *= 2, level++) {
            P.push_back(vector&lt;int&gt;(L, 0));
            for (int i = 0; i &lt; L; i++)
                M[i] = make_pair(make_pair(P[level - 1][i], i + skip &lt; L ? P[level - 1][i + skip] : -1000), i);
            sort(M.begin(), M.end());
            for (int i = 0; i &lt; L; i++)
                P[level][M[i].second] = (i &gt; 0 &amp;&amp; M[i].first == M[i - 1].first) ? P[level][M[i - 1].second] : i;
        }
        for (unsigned i = 0; i &lt; P.back().size(); ++i) {
            rank[i] = P.back()[i];
            sa[rank[i]] = i;
        }
    }

    // This is a traditional way to calculate LCP
    void getHeight() {
        memset(height, 0, sizeof height);
        int k = 0;
        for (int i = 0; i &lt; L; ++i) {
            if (rank[i] == 0) continue;
            if (k) k--;
            int j = sa[rank[i] - 1];
            while (i + k &lt; L &amp;&amp; j + k &lt; L &amp;&amp; s[i + k] == s[j + k]) ++k;
            height[rank[i]] = k;
        }
        rmq_init(height, L);
    }

    int f[N][Nlog];
    inline int highbit(int x) {
        return 31 - __builtin_clz(x);
    }

    int rmq_query(int x, int y) {
        int p = highbit(y - x + 1);
        return min(f[x][p], f[y - (1 &lt;&lt; p) + 1][p]);
    }

    // arr has to be 0 based
    void rmq_init(int *arr, int length) {
        for (int x = 0; x &lt;= highbit(length); ++x)
            for (int i = 0; i &lt;= length - (1 &lt;&lt; x); ++i) {
                if (!x) f[i][x] = arr[i];
                else f[i][x] = min(f[i][x - 1], f[i + (1 &lt;&lt; (x - 1))][x - 1]);
            }
    }

    #ifdef NEW
    // returns the length of the longest common prefix of s[i...L-1] and s[j...L-1]
    int LongestCommonPrefix(int i, int j) {
        int len = 0;
        if (i == j) return L - i;
        for (int k = (int) P.size() - 1; k &gt;= 0 &amp;&amp; i &lt; L &amp;&amp; j &lt; L; k--) {
            if (P[k][i] == P[k][j]) {
                i += 1 &lt;&lt; k;
                j += 1 &lt;&lt; k;
                len += 1 &lt;&lt; k;
            }
        }
        return len;
    }
    #else
    int LongestCommonPrefix(int i, int j) {
        // getHeight() must be called first
        if (i == j) return L - i;
        if (i &gt; j) swap(i, j);
        return rmq_query(i + 1, j);
    }
    #endif

    int checkNonOverlappingSubstring(int K) {
        // check if there is two non-overlapping identical substring of length K
        int minsa = 0, maxsa = 0;
        for (int i = 0; i &lt; L; ++i) {
            if (height[i] &lt; K) {
                minsa = sa[i]; maxsa = sa[i];
            } else {
                minsa = min(minsa, sa[i]);
                maxsa = max(maxsa, sa[i]);
                if (maxsa - minsa &gt;= K) return 1;
            }
        }
        return 0;
    }

    int checkBelongToDifferentSubstring(int K, int split) {
        int minsa = 0, maxsa = 0;
        for (int i = 0; i &lt; L; ++i) {
            if (height[i] &lt; K) {
                minsa = sa[i]; maxsa = sa[i];
            } else {
                minsa = min(minsa, sa[i]);
                maxsa = max(maxsa, sa[i]);
                if (maxsa &gt; split &amp;&amp; minsa &lt; split) return 1;
            }
        }
        return 0;
    }

} *S;

int main() {
    string s, t;
    cin &gt;&gt; s &gt;&gt; t;
    int sp = s.length();
    s += &quot;*&quot; + t;
    S = new SuffixArray(s);
    S-&gt;getHeight();
    int left = 0, right = sp;
    while (left &lt; right) {
        int mid = (left + right + 1) / 2;
        if (S-&gt;checkBelongToDifferentSubstring(mid, sp))
            left = mid;
        else right = mid - 1;
    }
    printf(&quot;%d\n&quot;, left);
}
</code></pre>
<ul>
<li>SA-IS</li>
<li>仅在后缀自动机被卡内存或者卡常且需要 O(1) LCA 的情况下使用（比赛中敲这个我觉得不行）</li>
<li>UOJ 35</li>
</ul>
<pre><code class="language-cpp">// rk [0..n-1] -&gt; [1..n], sa/ht [1..n]
// s[i] &gt; 0 &amp;&amp; s[n] = 0
// b: normally as bucket
// c: normally as bucket1
// d: normally as bucket2
// f: normally as cntbuf

template&lt;size_t size&gt;
struct SuffixArray {
    bool t[size &lt;&lt; 1];
    int b[size], c[size];
    int sa[size], rk[size], ht[size];
    inline bool isLMS(const int i, const bool *t) { return i &gt; 0 &amp;&amp; t[i] &amp;&amp; !t[i - 1]; }
    template&lt;class T&gt;
    inline void inducedSort(T s, int *sa, const int n, const int M, const int bs,
                            bool *t, int *b, int *f, int *p) {
        fill(b, b + M, 0); fill(sa, sa + n, -1);
        FOR (i, 0, n) b[s[i]]++;
        f[0] = b[0];
        FOR (i, 1, M) f[i] = f[i - 1] + b[i];
        FORD (i, bs - 1, -1) sa[--f[s[p[i]]]] = p[i];
        FOR (i, 1, M) f[i] = f[i - 1] + b[i - 1];
        FOR (i, 0, n) if (sa[i] &gt; 0 &amp;&amp; !t[sa[i] - 1]) sa[f[s[sa[i] - 1]]++] = sa[i] - 1;
        f[0] = b[0];
        FOR (i, 1, M) f[i] = f[i - 1] + b[i];
        FORD (i, n - 1, -1) if (sa[i] &gt; 0 &amp;&amp; t[sa[i] - 1]) sa[--f[s[sa[i] - 1]]] = sa[i] - 1;
    }
    template&lt;class T&gt;
    inline void sais(T s, int *sa, int n, bool *t, int *b, int *c, int M) {
        int i, j, bs = 0, cnt = 0, p = -1, x, *r = b + M;
        t[n - 1] = 1;
        FORD (i, n - 2, -1) t[i] = s[i] &lt; s[i + 1] || (s[i] == s[i + 1] &amp;&amp; t[i + 1]);
        FOR (i, 1, n) if (t[i] &amp;&amp; !t[i - 1]) c[bs++] = i;
        inducedSort(s, sa, n, M, bs, t, b, r, c);
        for (i = bs = 0; i &lt; n; i++) if (isLMS(sa[i], t)) sa[bs++] = sa[i];
        FOR (i, bs, n) sa[i] = -1;
        FOR (i, 0, bs) {
            x = sa[i];
            for (j = 0; j &lt; n; j++) {
                if (p == -1 || s[x + j] != s[p + j] || t[x + j] != t[p + j]) { cnt++, p = x; break; }
                else if (j &gt; 0 &amp;&amp; (isLMS(x + j, t) || isLMS(p + j, t))) break;
            }
            x = (~x &amp; 1 ? x &gt;&gt; 1 : x - 1 &gt;&gt; 1), sa[bs + x] = cnt - 1;
        }
        for (i = j = n - 1; i &gt;= bs; i--) if (sa[i] &gt;= 0) sa[j--] = sa[i];
        int *s1 = sa + n - bs, *d = c + bs;
        if (cnt &lt; bs) sais(s1, sa, bs, t + n, b, c + bs, cnt);
        else FOR (i, 0, bs) sa[s1[i]] = i;
        FOR (i, 0, bs) d[i] = c[sa[i]];
        inducedSort(s, sa, n, M, bs, t, b, r, d);
    }
    template&lt;typename T&gt;
    inline void getHeight(T s, const int n, const int *sa) {
        for (int i = 0, k = 0; i &lt; n; i++) {
            if (rk[i] == 0) k = 0;
            else {
                if (k &gt; 0) k--;
                int j = sa[rk[i] - 1];
                while (i + k &lt; n &amp;&amp; j + k &lt; n &amp;&amp; s[i + k] == s[j + k]) k++;
            }
            ht[rk[i]] = k;
        }
    }
    template&lt;class T&gt;
    inline void init(T s, int n, int M) {
        sais(s, sa, ++n, t, b, c, M);
        for (int i = 1; i &lt; n; i++) rk[sa[i]] = i;
        getHeight(s, n, sa);
    }
};

const int N = 2E5 + 100;
SuffixArray&lt;N&gt; sa;

int main() {
    string s; cin &gt;&gt; s; int n = s.length();
    sa.init(s, n, 128);
    FOR (i, 1, n + 1) printf(&quot;%d%c&quot;, sa.sa[i] + 1, i == _i - 1 ? '\n' : ' ');
    FOR (i, 2, n + 1) printf(&quot;%d%c&quot;, sa.ht[i], i == _i - 1 ? '\n' : ' ');
}
</code></pre>
<h2 id="kmp">KMP</h2>
<ul>
<li>前缀函数（每一个前缀的最长 border）</li>
</ul>
<pre><code class="language-cpp">void get_pi(int a[], char s[], int n) {
    int j = a[0] = 0;
    FOR (i, 1, n) {
        while (j &amp;&amp; s[i] != s[j]) j = a[j - 1];
        a[i] = j += s[i] == s[j];
    }
}
</code></pre>
<ul>
<li>Z 函数（每一个后缀和该字符串的 LCP 长度）</li>
</ul>
<pre><code class="language-cpp">void get_z(int a[], char s[], int n) {
    int l = 0, r = 0; a[0] = n;
    FOR (i, 1, n) {
        a[i] = i &gt; r ? 0 : min(r - i + 1, a[i - l]);
        while (i + a[i] &lt; n &amp;&amp; s[a[i]] == s[i + a[i]]) ++a[i];
        if (i + a[i] - 1 &gt; r) { l = i; r = i + a[i] - 1; }
    }
}
</code></pre>
<h2 id="trie">Trie</h2>
<pre><code class="language-cpp">namespace trie {
    int t[N][26], sz, ed[N];
    void init() { sz = 2; memset(ed, 0, sizeof ed); }
    int _new() { memset(t[sz], 0, sizeof t[sz]); return sz++; }
    void ins(char* s, int p) {
        int u = 1;
        FOR (i, 0, strlen(s)) {
            int c = s[i] - 'a';
            if (!t[u][c]) t[u][c] = _new();
            u = t[u][c];
        }
        ed[u] = p;
    }
}
</code></pre>
<h2 id="ac">AC 自动机</h2>
<pre><code class="language-cpp">const int N = 1e6 + 100, M = 26;

int mp(char ch) { return ch - 'a'; }

struct ACA {
    int ch[N][M], danger[N], fail[N];
    int sz;
    void init() {
        sz = 1;
        memset(ch[0], 0, sizeof ch[0]);
        memset(danger, 0, sizeof danger);
    }
    void insert(const string &amp;s, int m) {
        int n = s.size(); int u = 0, c;
        FOR (i, 0, n) {
            c = mp(s[i]);
            if (!ch[u][c]) {
                memset(ch[sz], 0, sizeof ch[sz]);
                danger[sz] = 0; ch[u][c] = sz++;
            }
            u = ch[u][c];
        }
        danger[u] |= 1 &lt;&lt; m;
    }
    void build() {
        queue&lt;int&gt; Q;
        fail[0] = 0;
        for (int c = 0, u; c &lt; M; c++) {
            u = ch[0][c];
            if (u) { Q.push(u); fail[u] = 0; }
        }
        while (!Q.empty()) {
            int r = Q.front(); Q.pop();
            danger[r] |= danger[fail[r]];
            for (int c = 0, u; c &lt; M; c++) {
                u = ch[r][c];
                if (!u) {
                    ch[r][c] = ch[fail[r]][c];
                    continue;
                }
                fail[u] = ch[fail[r]][c];
                Q.push(u);
            }
        }
    }
} ac;

char s[N];

int main() {
    int n; scanf(&quot;%d&quot;, &amp;n);
    ac.init();
    while (n--) {
        scanf(&quot;%s&quot;, s);
        ac.insert(s, 0);
    }
    ac.build();

    scanf(&quot;%s&quot;, s);
    int u = 0; n = strlen(s);
    FOR (i, 0, n) {
        u = ac.ch[u][mp(s[i])];
        if (ac.danger[u]) {
            puts(&quot;YES&quot;);
            return 0;
        }
    }
    puts(&quot;NO&quot;);
    return 0;
}
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../../../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../../../../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../../../../../js/base.js"></script>
        <script src="../../../../../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
